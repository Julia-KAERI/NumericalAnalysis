<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.56">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>행렬의 분해 – 수치해석과 이미지 처리</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../src/numerical_analysis_using_julia/09_iterative_method_for_linear_system.html" rel="next">
<link href="../../src/numerical_analysis_using_julia/index_part2.html" rel="prev">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-sidebar docked nav-fixed slimcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">수치해석과 이미지 처리</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="탐색 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../src/numerical_analysis_using_julia/index_part1.html"> 
<span class="menu-text">수치해석 I</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="../../src/numerical_analysis_using_julia/index_part2.html" aria-current="page"> 
<span class="menu-text">수치해석 II</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../src/image_processing/index.html"> 
<span class="menu-text">영상 처리/토모그래피</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../src/topics/nonlinear_least_square_fit.html"> 
<span class="menu-text">다양한 주제들</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
    <a href="mailto:julia.kaeri@gmail.com" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-envelope"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="사이드바 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../src/numerical_analysis_using_julia/08_matrix_decomposition.html">행렬의 분해</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="사이드바 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/numerical_analysis_using_julia/index_part2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">수치해석 II</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/numerical_analysis_using_julia/08_matrix_decomposition.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">행렬의 분해</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/numerical_analysis_using_julia/09_iterative_method_for_linear_system.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">선형방정식과 반복법</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/numerical_analysis_using_julia/10_least_square_problem.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">최소자승 문제</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/numerical_analysis_using_julia/11_ode_initial_value_problem_1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">상미분 방정식의 초기값 문제-I</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/numerical_analysis_using_julia/12_ode_initial_value_problem_2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">상미분 방정식의 초기값 문제-II</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/numerical_analysis_using_julia/13_ode_boundary_value_problem.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">상미분 방정식의 경계값 문제</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/numerical_analysis_using_julia/14_approximation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Approximation</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/numerical_analysis_using_julia/15_pde_1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">편미분 방정식</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">수학적 자료</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="토글 섹션">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/numerical_analysis_using_julia/A_collection_of_proofs.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">수학적 증명</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/numerical_analysis_using_julia/A_generalized_inverse.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">일반화된 역행렬과 의사 역행렬</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/numerical_analysis_using_julia/A_ode.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">상미분 방정식</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/numerical_analysis_using_julia/A_pde.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">편미분 방정식의 이론적 배경</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul>
  <li><a href="#수학적-기초" id="toc-수학적-기초" class="nav-link active" data-scroll-target="#수학적-기초"><span class="header-section-number">1</span> 수학적 기초</a>
  <ul class="collapse">
  <li><a href="#대각-지배-행렬" id="toc-대각-지배-행렬" class="nav-link" data-scroll-target="#대각-지배-행렬">대각 지배 행렬</a></li>
  <li><a href="#positive-definite-행렬" id="toc-positive-definite-행렬" class="nav-link" data-scroll-target="#positive-definite-행렬">Positive Definite 행렬</a></li>
  </ul></li>
  <li><a href="#숄레스키-분해" id="toc-숄레스키-분해" class="nav-link" data-scroll-target="#숄레스키-분해"><span class="header-section-number">2</span> 숄레스키 분해</a>
  <ul class="collapse">
  <li><a href="#boldsymbolllast-분해" id="toc-boldsymbolllast-분해" class="nav-link" data-scroll-target="#boldsymbolllast-분해"><span class="math inline">\(\boldsymbol{LL}^\ast\)</span> 분해</a></li>
  <li><a href="#구현" id="toc-구현" class="nav-link" data-scroll-target="#구현">구현</a></li>
  <li><a href="#boldsymbolldlast-분해" id="toc-boldsymbolldlast-분해" class="nav-link" data-scroll-target="#boldsymbolldlast-분해"><span class="math inline">\(\boldsymbol{LDL}^\ast\)</span> 분해</a></li>
  <li><a href="#sec-crout_decompositioni" id="toc-sec-crout_decompositioni" class="nav-link" data-scroll-target="#sec-crout_decompositioni">크라우트 분해</a></li>
  </ul></li>
  <li><a href="#qr-분해" id="toc-qr-분해" class="nav-link" data-scroll-target="#qr-분해"><span class="header-section-number">3</span> QR 분해</a>
  <ul class="collapse">
  <li><a href="#하우스홀더-행렬" id="toc-하우스홀더-행렬" class="nav-link" data-scroll-target="#하우스홀더-행렬">하우스홀더 행렬</a></li>
  <li><a href="#하우스홀더-변환과-하우스홀더-반사" id="toc-하우스홀더-변환과-하우스홀더-반사" class="nav-link" data-scroll-target="#하우스홀더-변환과-하우스홀더-반사">하우스홀더 변환과 하우스홀더 반사</a></li>
  <li><a href="#실벡터-공간에서의-하우스홀더-변환과-qr-분해" id="toc-실벡터-공간에서의-하우스홀더-변환과-qr-분해" class="nav-link" data-scroll-target="#실벡터-공간에서의-하우스홀더-변환과-qr-분해">실벡터 공간에서의 하우스홀더 변환과 QR 분해</a></li>
  <li><a href="#복소벡터공간에서의-qr-분해" id="toc-복소벡터공간에서의-qr-분해" class="nav-link" data-scroll-target="#복소벡터공간에서의-qr-분해">복소벡터공간에서의 QR 분해</a></li>
  </ul></li>
  <li><a href="#linearalgebra.jl" id="toc-linearalgebra.jl" class="nav-link" data-scroll-target="#linearalgebra.jl"><span class="header-section-number">4</span> <code>LinearAlgebra.jl</code></a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">행렬의 분해</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div class="hidden">
<p>% %</p>
%
<p><span class="math display">\[
\DeclarePairedDelimiters{\set}{\{}{\}}
\DeclareMathOperator*{\argmax}{argmax}
\]</span></p>
</div>
<p><br></p>
<p>선형 대수학에서 행렬 분해는 행렬을 다른 행렬들의 곱으로 분해하는 것을 말한다. 다양한 행렬 분해 방법이 존재하며, 각각은 특정 유형의 문제 해결에 활용된다. 수치 해석에서는 효율적인 행렬 알고리즘을 구현하는 데 다양한 분해 방법을 사용 할 수 있다. 우리는 이미 LU 분해를 하는 방법과 그 유용성을 알아 보았다. 여기서는 다양한 행렬의 분해에 대해 알아보고자 한다.</p>
<p><br></p>
<section id="수학적-기초" class="level2 page-columns page-full" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="수학적-기초"><span class="header-section-number">1</span> 수학적 기초</h2>
<section id="대각-지배-행렬" class="level3">
<h3 class="anchored" data-anchor-id="대각-지배-행렬">대각 지배 행렬</h3>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-diagonally_dominat_matrix" class="theorem definition">
<p><span class="theorem-title"><strong>정의 1 (대각 지배 행렬)</strong></span> 행렬 <span class="math inline">\(\boldsymbol{A}\in \mathbb{F}^{n\times n}\)</span> 의 각 행의 대각성분의 절대값이 그 행의 대각성분을 제외한 성분의 절대값의 합보다 크면, 즉 각각의 <span class="math inline">\(i=1,\ldots,\,n\)</span> 행에 대해</p>
<p><span class="math display">\[
|A_{ii}| \ge \sum_{j=1,\, j\ne i}^n |A_{ij}|, \qquad i=1,\ldots,\,n
\]</span></p>
<p>이면 이 행렬 <span class="math inline">\(\boldsymbol{A}\)</span> 를 <strong>행에 대한 대각 지배 행렬 (row-wise diagonally dominant matrix)</strong>이라 한다. 또한 각 열에대해</p>
<p><span class="math display">\[
|A_{ii}| \ge \sum_{j=1,\, j\ne i}^n |A_{ji}|, \qquad i=1,\ldots,\,n
\]</span></p>
<p>이면 이 행렬 <span class="math inline">\(\boldsymbol{A}\)</span> 를 <strong>열에 대한 대각 지배 행렬 (column-wise diagonally dominant matrix)</strong>이라 한다. 행/열 에 대한 대각 지배 행렬의 조건에서 등호 조건을 제외하고 성립하면 <strong>행/열 에 대한 엄격한 대각 지배 행렬 (strictly row-wise/column-wise diagonally dominant matrix)</strong> 이라고 한다.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<p>즉 각 행(열)에 대해 대각성분의 절대값이 나머지 그 행(열)의 성분의 절대값의 합보다 크거나 같으면 행(열)에 대한 대각지배행렬이다.</p>
<p><br></p>
<div class="border" style="background-color:#FFF0F5 ;padding:5px;">
<div id="prp-strictly_diagonallly_dominat_matrix_is_invertible" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 1</strong></span> 엄격한 대각 지배 행렬은 가역행렬이다.</p>
</div>
</div>
<p><br></p>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span>행에 대해 엄격한 대각 지배 행렬 <span class="math inline">\(\boldsymbol{A}\)</span> 이 가역행렬이면, <span class="math inline">\(\boldsymbol{A}^T\)</span> 는 열에 대해 엄격한 대각 지배 행렬이며 가역행렬이다. 따라서 행에 대해 엄격한 대각 지배 행렬이 가역행렬임을 보이면 된다.</p>
<p><span class="math inline">\(\boldsymbol{A}\in \mathbb{F}^{n \times n}\)</span> 이 행에 대한 엄격한 대각 지배 행렬이라고 하자. 어떤 <span class="math inline">\(\boldsymbol{x}(\ne \boldsymbol{0}) \in \mathbb{F}^n\)</span> 에 대해 <span class="math inline">\(\boldsymbol{Ax}=\boldsymbol{0}\)</span> 이면 <span class="math inline">\(\boldsymbol{A}\)</span> 는 가역행렬이 아니다. 따라서 <span class="math inline">\(\boldsymbol{Ax}=\boldsymbol{0}\)</span> 인 <span class="math inline">\(\boldsymbol{0}\)</span> 벡터가 아닌 <span class="math inline">\(\boldsymbol{x}\)</span> 가 존재한다고 가정하고 모순을 보이면 된다. <span class="math inline">\(\boldsymbol{x}\)</span> 의 성분 가운데 그 절대값이 가장 큰 <span class="math inline">\(|x_k|\ne 0\)</span> 을 찾을 수 있다. <span class="math inline">\(\boldsymbol{Ax}=\boldsymbol{0}\)</span> 이므로, 각각의 <span class="math inline">\(i=1,\ldots,\,n\)</span> 에 대해</p>
<p><span class="math display">\[
\sum_{j=1}^n A_{ij}x_j=0
\]</span></p>
<p>이며, 따라서 <span class="math inline">\(x_k\)</span> 의 <span class="math inline">\(k\)</span> 에 대해</p>
<p><span class="math display">\[
A_{kk}x_k = -\sum_{j=1,\,j \ne k}^n A_{kj}x_j
\]</span></p>
<p>이다. <span class="math inline">\(\boldsymbol{A}\)</span> 가 행에 대해 엄격한 대각 지배 행렬이므로 모든 대각성분은 <span class="math inline">\(0\)</span> 이 아니다. 삼각부등식에 의해,</p>
<p><span class="math display">\[
|A_{kk}| |x_k|  \le \sum_{j=1,\,j\ne k}^n |A_{kj}| |x_j|
\]</span></p>
<p>이 성립하며 <span class="math display">\[
|A_{kk}| \le \sum_{j= 1,\, j \ne k}^n \dfrac{|x_j|}{|x_k|} |A_{kj}| &lt; \sum_{j= 1,\, j \ne k}^n |A_{kj}|
\]</span></p>
<p>이므로 <span class="math inline">\(\boldsymbol{A}\)</span> 가 행에 대해 엄격한 대각 지배 행렬이라는 가정에 위배된다. 따라서 <span class="math inline">\(\boldsymbol{A}\)</span> 는 가역행렬이다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
<div class="border" style="background-color:#FFF0F5 ;padding:5px;">
<div id="prp-diagonally_dominant_matrix_and_LU_factorization" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 2</strong></span> 행에 대해 엄격한 대각 지배 행렬은 피보팅 없이 가우스-요르단 소거법을 수행 할 수 있다.</p>
</div>
</div>
<p><br></p>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span><span class="math inline">\(\boldsymbol{A}\in \mathbb{F}^{n \times n}\)</span> 가 행에 대해 엄격한 대각 지배 행렬일 때 induction 으로 증명한다. 우선 <span class="math inline">\(n=1\)</span> 일 경우는 자명하다. <span class="math inline">\(n\)</span> 에 대해 명제가 성립함을 가정하자. 가우스-요르단 소거법을 첫번째 행을 가준으로 하여 피보팅 없이 두번째 행부터 <span class="math inline">\(n+1\)</span> 번째 행까지 첫번째 열을 소거한 행렬을 <span class="math inline">\(\boldsymbol{A}'\)</span> 이라 하면 <span class="math display">\[
A'_{ij} = A_{ij}- \dfrac{A_{i1}}{A_{11}}A_{1j},\qquad i=2,\ldots,\,n+1 \tag{1}
\]</span></p>
<p>이다.</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{j=2,\, j\ne i}^n |A'_{ij}| &amp;= \sum_{j=2,\, j \ne i} \left|A_{ij}- \dfrac{A_{i1}}{A_{11}}A_{1j}\right| \le \sum_{j=2,\, j \ne i}^n |A_{ij}| + \sum_{j=2,\,j \ne i} \left|\dfrac{A_{i1}}{A_{11}}A_{1j}\right|
\end{aligned}\tag{2}
\]</span></p>
<p>이다. 행에 대한 엄격한 지배행렬이라는 조건으로 부터 다음을 얻는다.</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{j=2,\, j \ne i}^n |A_{ij}| &lt; |A_{ii}| - |A_{i1}|,\\
\sum_{j=2,\, j \ne i}^n |A_{1j}| &lt; |A_{11}| - |A_{1i}|
\end{aligned} \tag{3}
\]</span></p>
<p>위 식을 이용하여 <span class="math inline">\((3)\)</span> 를 보면 <span class="math display">\[
\sum_{j=2,\, j\ne i}^n |A'_{ij}| &lt; |A_{ii}|-|A_{i1}| + \dfrac{|A_{i1}|}{|A_{11}|} \left(|A_{11}| - |A_{1i}|\right) = |A_{ii}| - \dfrac{|A_{i1}|}{|A_{11}|} |A_{1i}| \tag{4}
\]</span></p>
<p>이다. <span class="math inline">\((1)\)</span> 로 부터,</p>
<p><span class="math display">\[
|A'_{ii}| = \left|A_{ii}- \dfrac{A_{i1}}{A_{11}}A_{1i}\right| \ge \left|A_{ii}\right|- \left|\dfrac{A_{i1}}{A_{11}}A_{1i}\right| \tag{5}
\]</span></p>
<p>이므로, <span class="math inline">\((4)\)</span> 와 <span class="math inline">\((5)\)</span> 를 결합하면,</p>
<p><span class="math display">\[
|A'_{ii}| &gt; \sum_{j=2,\, j\ne i}^n |A'_{ij}|
\]</span></p>
<p>이다. 즉 2행 2열부터 <span class="math inline">\(n+1\)</span> 행 <span class="math inline">\(n+1\)</span> 열까지의 <span class="math inline">\(\boldsymbol{A}'\)</span> 의 부분행렬은 행에 대해 엄격한 지배행렬이므로 가정에 의해 피보팅 없이 가우스-조르단 소거법을 수행 할 수 있다. 따라서 임의의 크기의 정사각 행렬이 행에 대해 엄격한 대각 지배 행렬일 때, 피보팅 없이 가우스-조르단 소거법을 수행 할 수 있다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
</section>
<section id="positive-definite-행렬" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="positive-definite-행렬">Positive Definite 행렬</h3>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-positive_definite_matrices" class="theorem definition">
<p><span class="theorem-title"><strong>정의 2 (Positive definite 행렬)</strong></span> 행렬 <span class="math inline">\(\boldsymbol{A}\in \mathbb{F}^{n \times n}\)</span> 이 에르미트 행렬이며 모든 <span class="math inline">\(\boldsymbol{x}\in \mathbb{F}^n\)</span>, <span class="math inline">\(\boldsymbol{x}\ne \boldsymbol{0}\)</span> 에 대해 <span class="math inline">\(\langle \boldsymbol{Ax},\boldsymbol{x}\rangle &gt; 0\)</span> 일 경우, 즉 <span class="math inline">\(\boldsymbol{x}^T\boldsymbol{Ax}&gt;0\)</span> 일 경우 <span class="math inline">\(\boldsymbol{A}\)</span> 를 <strong>positive definite</strong> 라 한다.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<p>Positive definite 행렬은 복소수체에서 정의할 수도 있으나 여기서는 실수체에서 정의된 행렬만 생각하기로 한다. Positive definite 행렬은 정의상 대칭행렬이므로 <a href="../../src/numerical_analysis_using_julia/02_notations_and_propositions.html#">Interude : 수학에 관련된 표기법과 명제들</a> 의 <a href="../../src/numerical_analysis_using_julia/02_notations_and_propositions.html#prp-properties_of_hermitian_matrix">실수체에서 정의된 행렬의 스펙트럼 정리</a> 를 만족한다. 즉 모든 <span class="math inline">\(\boldsymbol{x}\in\mathbb{R}^n\)</span> 은 <span class="math inline">\(\boldsymbol{A}\)</span> 의 고유벡터의 선형결합으로 표현 할 수 있다. 이제 positive definite 행렬에 대한 성질을 알아보자.</p>
<p><br></p>
<div class="border" style="background-color:#FFF0F5 ;padding:5px;">
<div id="prp-positive_definite_matrix_1" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 3</strong></span> <span class="math inline">\(\boldsymbol{A}\in \mathbb{R}^{n \times n}\)</span> 이 positive definite 일 경우 다음이 성립한다.</p>
<p>  (<span class="math inline">\(1\)</span>) <span class="math inline">\(\boldsymbol{A}\)</span> 의 모든 고유값은 양수이다.</p>
<p>  (<span class="math inline">\(2\)</span>) <span class="math inline">\(\det (\boldsymbol{A}) &gt;0\)</span> 이다.</p>
<p>  (<span class="math inline">\(3\)</span>) <span class="math inline">\(\boldsymbol{A}\)</span> 는 가역행렬이다.</p>
<p>  (<span class="math inline">\(4\)</span>) <span class="math inline">\(\boldsymbol{A}\)</span> 의 대각성분은 모두 양수이다.</p>
<p>  (<span class="math inline">\(5\)</span>) <span class="math inline">\(|A_{ij}| \le \max \{|A_{ii}| : i=1,\ldots,\,n\}\)</span>.</p>
<p>  (<span class="math inline">\(6\)</span>) 모든 <span class="math inline">\(i\ne j\)</span> 에 대해 <span class="math inline">\((A_{ij})^2 &lt; A_{ii} A_{jj}\)</span> 이다.</p>
</div>
</div>
<p><br></p>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span>(<span class="math inline">\(1\)</span>) <span class="math inline">\(\lambda\)</span> 가 <span class="math inline">\(\boldsymbol{A}\)</span> 의 고유값이며 <span class="math inline">\(\boldsymbol{v}\)</span> 가 <span class="math inline">\(\lambda\)</span> 에 대한 고유벡터일 경우 <span class="math inline">\(\lambda = \langle \boldsymbol{Av}, \boldsymbol{v}\rangle &gt;0\)</span> 이어야 한다.</p>
<p>(<span class="math inline">\(2\)</span>) 대칭행렬 <span class="math inline">\(\boldsymbol{A}\)</span> 의 행렬식은 모든 고유값의 곱이므로 양수이다.</p>
<p>(<span class="math inline">\(3\)</span>) <span class="math inline">\(\boldsymbol{x}\ne 0\)</span> 이며 <span class="math inline">\(\boldsymbol{Ax}=\boldsymbol{0}\)</span> 일 경우 <span class="math inline">\(\langle \boldsymbol{Ax}, \boldsymbol{x}\rangle = 0\)</span> 인데 이는 <span class="math inline">\(\boldsymbol{A}\)</span> 가 positive definite 가 아니라는 의미이다.</p>
<p>(<span class="math inline">\(4\)</span>) <span class="math inline">\(A_{ii} = \langle \boldsymbol{A}\hat{\boldsymbol{e}}_i,\, \hat{\boldsymbol{e}}_i\rangle  &gt; 0\)</span></p>
<p>(<span class="math inline">\(5\)</span>) <span class="math inline">\(i\ne j\)</span> 에 대해</p>
<p><span class="math display">\[
\begin{aligned}
0&lt; \langle \boldsymbol{A}(\hat{\boldsymbol{e}}_i-\hat{\boldsymbol{e}}_j), (\hat{\boldsymbol{e}}_i-\hat{\boldsymbol{e}}_j)\rangle = A_{ii}+ A_{jj} - 2 A_{ij} \\
0&lt; \langle \boldsymbol{A}(\hat{\boldsymbol{e}}_i+\hat{\boldsymbol{e}}_j), (\hat{\boldsymbol{e}}_i+\hat{\boldsymbol{e}}_j)\rangle = A_{ii}+ A_{jj} + 2 A_{ij} \\
\end{aligned}
\]</span></p>
<p>이므로 <span class="math display">\[
|A_{ij}| &lt; \dfrac{A_{ii}+A_{jj}}{2} \le \max \{|A_{ii}| : i=1,\ldots,\,n\}
\]</span></p>
<p>이다.</p>
<p>(<span class="math inline">\(6\)</span>) 임의의 실수 <span class="math inline">\(t\)</span> 에 대해 <span class="math inline">\(\boldsymbol{x} = \hat{\boldsymbol{e}}_i + t \hat{\boldsymbol{e}}_j\)</span> 라고 하자. <span class="math inline">\(\langle \boldsymbol{Ax},\,\boldsymbol{x}\rangle = t^2A_{ii} + 2tA_{ij} + A_{jj} &gt; 0\)</span> 이므로 <span class="math inline">\((A_{ij})^2-A_{ii}A_{ij}&lt;0\)</span> 이어야 한다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-submatrix" class="theorem definition">
<p><span class="theorem-title"><strong>정의 3 (부분 행렬과 선행 주 부분 행렬)</strong></span> 행렬 <span class="math inline">\(\boldsymbol{A}\in \mathbb{F}^{n \times n}\)</span> 에 대해 임의의 중복되지 않은 행 <span class="math inline">\(I=\{i_1,\ldots,\,i_p: 1\le i_k\le m\}\)</span> 과 중복되지 않은 열 <span class="math inline">\(J=\{j_1,\ldots,\,j_q: 1 \le j_l \le n \}\)</span> 을 모아 만든 행렬을 <span class="math inline">\(\boldsymbol{A}\)</span> 의 <strong>부분 행렬 (submatrix)</strong>이라고 하고 <span class="math inline">\(\boldsymbol{A}[I, J]\)</span> 라고 쓴다. <span class="math inline">\(I=J=\{1,\,2,\ldots,\,k\}\)</span>일 때 <span class="math inline">\(\boldsymbol{A}[I, J]\)</span> 를 <strong>선행 주 부분 행렬 (leading principal submatrix)</strong> 이라고 한다.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<p>이제 정사각 행렬 <span class="math inline">\(\boldsymbol{A}\)</span> 가 positive definite 인 것과 <span class="math inline">\(\boldsymbol{A}\)</span> 의 모든 선행 주 부분행렬의 행렬식이 <span class="math inline">\(0\)</span> 보다 큰 것이 동치임을 보이고자 한다. 이를 위해 몇가지 미리 보여야 할 것이 있다.</p>
<div class="border" style="background-color:#FFF0F5 ;padding:5px;">
<div id="lem-positive_definite" class="theorem lemma">
<p><span class="theorem-title"><strong>보조정리 1</strong></span> <span class="math inline">\(\boldsymbol{A}\in \mathbb{F}^{n \times n}\)</span> 이 에르미트행렬이고 <span class="math inline">\(\boldsymbol{Q} \in \mathbb{F}^{n \times n}\)</span> 이 가역행렬 일 때 다음은 동치이다.</p>
<p>  (<span class="math inline">\(1\)</span>) <span class="math inline">\(\boldsymbol{A}\)</span> 가 positive definite 이고 <span class="math inline">\(\boldsymbol{Q}^\ast\boldsymbol{AQ}\)</span> 가 에르미트행렬이다.</p>
<p>  (<span class="math inline">\(2\)</span>) <span class="math inline">\(\boldsymbol{Q}^\ast \boldsymbol{AQ}\)</span> 가 positive definte 이다.</p>
</div>
</div>
<p><br></p>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span>(<span class="math inline">\(1 \implies 2\)</span>) <span class="math inline">\(\boldsymbol{0}\)</span> 벡터가 아닌 <span class="math inline">\(\boldsymbol{v}\in \mathbb{F}^n\)</span> 에 대해 <span class="math inline">\(\boldsymbol{Qv}\ne \boldsymbol{0}\)</span> 이다. <span class="math inline">\(\boldsymbol{A}\)</span> 가 positive definite 이므로,</p>
<p><span class="math display">\[
0 &lt; (\boldsymbol{Qv})^\ast \boldsymbol{A}(\boldsymbol{Qv}) = \boldsymbol{v}^\ast \left(\boldsymbol{Q}^\ast\boldsymbol{AQ}\right)\boldsymbol{v}
\]</span></p>
<p>이므로 <span class="math inline">\(\boldsymbol{Q}^\ast\boldsymbol{AQ}\)</span> 는 positive definite 이다.</p>
<p>(<span class="math inline">\(2 \implies 1\)</span>) <span class="math inline">\(\boldsymbol{A}\)</span> 가 에르미트행렬이므로 <span class="math inline">\((\boldsymbol{Q}^\ast\boldsymbol{AQ})^\ast = \boldsymbol{Q}^\ast \boldsymbol{A}^\ast\boldsymbol{Q} = \boldsymbol{Q}^\ast\boldsymbol{AQ}\)</span> 이다. 즉 <span class="math inline">\(\boldsymbol{Q}^\ast\boldsymbol{AQ}\)</span> 는 에르미트행렬이다. <span class="math inline">\(\boldsymbol{Q}\)</span> 가 가역이므로 임의의 <span class="math inline">\(\boldsymbol{x}\in \mathcal{M}_n(\mathbb{F})\)</span> 에 대해 <span class="math inline">\(\boldsymbol{x}=\boldsymbol{Qy}\)</span> 를 만족하는 <span class="math inline">\(\boldsymbol{y}\in \mathcal{M}_n(\mathbb{F})\)</span> 이 존재한다.</p>
<p><span class="math display">\[
\boldsymbol{x}^\ast\boldsymbol{Ax} =  (\boldsymbol{Qy})^\ast \boldsymbol{A}\boldsymbol{Qy} = \boldsymbol{y}^\ast\boldsymbol{Q}^\ast\boldsymbol{AQ}\boldsymbol{y} &gt; 0
\]</span></p>
<p>이므로 <span class="math inline">\(\boldsymbol{A}\)</span> 는 positive defnite 이다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
<div class="border" style="background-color:#FFF0F5 ;padding:5px;">
<div id="prp-leading_principal_submatrix" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 4 (실베스터 판정법 (Sylvester’s criterion))</strong></span> 에르미트 행렬 <span class="math inline">\(\boldsymbol{A}\)</span> 에 대해 다음은 동치이다.</p>
<p>  (<span class="math inline">\(1\)</span>) <span class="math inline">\(\boldsymbol{A}\)</span> 의 모든 선행 주 부분 행렬의 행렬식이 양수이다.</p>
<p>  (<span class="math inline">\(2\)</span>) <span class="math inline">\(\boldsymbol{A}\)</span> 는 positive definite 이다.</p>
</div>
</div>
<div class="page-columns page-full"><p><br> </p><div class="no-row-height column-margin column-container"><span class="margin-aside"><a href="#prp-leading_principal_submatrix" class="quarto-xref">명제&nbsp;4</a> 가 실베스터 판정법이라고 불리우는 것은 임의의 에르미트 행렬이 positive definite 인지 아닌지를 확인하는 방법이기 때문이다.</span></div></div>
<div class="proof page-columns page-full">
<p><span class="proof-title"><em>(증명)</em>. </span><span class="math inline">\(\boldsymbol{A}\)</span> 의 <span class="math inline">\(k\)</span> 행 <span class="math inline">\(k\)</span> 열 까지의 선 주 부분행렬을 <span class="math inline">\(\boldsymbol{A}_k\)</span> 라고 쓰자.</p>
<div class="page-columns page-full"><p>(<span class="math inline">\(1\implies 2\)</span>) Inductinon 을 통해 증명한다. <span class="math inline">\(1 \times 1\)</span> 행렬의 경우는 trivial 하다. 이제 <span class="math inline">\(n\times n\)</span> 행렬에 대해 성립한다고 가정한다. <span class="math inline">\(\boldsymbol{A}\)</span> 가 <span class="math inline">\((n+1)\times (n+1)\)</span> 행렬이라 하자.</p><div class="no-row-height column-margin column-container"><span class="margin-aside">Carl P.Simon &amp; Lawrence E. Blume 의 <em>Mathematics for Economists</em> 에 나오는 증명이다.</span></div></div>
<p>우선 모든 <span class="math inline">\(\boldsymbol{A}_i\)</span>, <span class="math inline">\(i=1,\ldots,\,n\)</span> 의 행렬식이 양수이면 <span class="math inline">\(\boldsymbol{A}\)</span> 가 positive definite 임을 보이자. 우선 <span class="math inline">\(\boldsymbol{A}\)</span> 를 <span class="math inline">\(\boldsymbol{A}_n\)</span> 에 대하여 아래와 같이 분할하여 보자.</p>
<p><span class="math display">\[
\boldsymbol{A} = \left[\begin{array}{c|c} \boldsymbol{A}_n &amp; \boldsymbol{a} \\ \hline \boldsymbol{a}^\ast &amp; a\end{array}\right].
\]</span></p>
<p>여기서 <span class="math inline">\(\boldsymbol{a}=\begin{bmatrix} A_{1, n+1} &amp; \cdots &amp; A_{n, n+1}\end{bmatrix}^T\)</span> 이고 <span class="math inline">\(a=A_{n+1, n+1}\)</span> 이다. 또한 <span class="math inline">\(\boldsymbol{A}\)</span> 가 에르미트행렬이므로 <span class="math inline">\(\boldsymbol{A}_n\)</span> 도 에르미트행렬이며 따라서 <span class="math inline">\((\boldsymbol{A}^\ast)^{-1}=\boldsymbol{A}^{-1}\)</span> 이다. . 그렇다면,</p>
<p><span class="math display">\[
\boldsymbol{A} = \left[\begin{array}{c|c} \boldsymbol{I}_n &amp; \boldsymbol{0} \\ \hline (\boldsymbol{A}_n^{-1}\boldsymbol{a})^\ast &amp; 1\end{array}\right] \left[\begin{array}{c|c} \boldsymbol{A}_n &amp; \boldsymbol{0}_n \\ \hline (\boldsymbol{0}_n)^\ast &amp; d\end{array}\right] \left[\begin{array}{c|c} \boldsymbol{I}_n &amp; \boldsymbol{A}_n^{-1}\boldsymbol{a} \\ \hline (\boldsymbol{0}_n)^\ast &amp; 1\end{array}\right] = \boldsymbol{Q}^\ast\boldsymbol{BQ}
\]</span></p>
<p>이며 이 때 <span class="math inline">\(d=a-\boldsymbol{a}^\ast(\boldsymbol{A}_n)^{-1}\boldsymbol{a}\)</span> 이다. 우리는 <span class="math inline">\(\det (\boldsymbol{Q}^\ast) = \det (\boldsymbol{Q})=1\)</span> 이며 <span class="math inline">\(\det (\boldsymbol{B})=d \cdot \det (\boldsymbol{A}_n)\)</span> 임을 안다. 즉</p>
<p><span class="math display">\[
\det (\boldsymbol{A}) =  d \cdot \det (\boldsymbol{A}_n)
\]</span></p>
<p>이다. <span class="math inline">\(\boldsymbol{A}\)</span> 가 positive definite 이며 <span class="math inline">\(\det (\boldsymbol{A})&gt;0\)</span> 이므로 <span class="math inline">\(d&gt;0\)</span> 이다. 즉 모든 선행 주 부분행렬식이 양수이면 그 행렬은 positive definite 이다.</p>
<p>(<span class="math inline">\(2 \implies 1\)</span>) <span class="math inline">\(\boldsymbol{A}\)</span> 가 positive definite 임을 가정하자. 임의의 <span class="math inline">\(\boldsymbol{x}\in \mathcal{M}_{n+1}(\mathbb{R})\)</span> 에 대해 <span class="math inline">\(\boldsymbol{x} = \begin{bmatrix} \boldsymbol{x}_0 &amp; x \end{bmatrix}^T\)</span>, <span class="math inline">\(\boldsymbol{x}_0 \in \mathcal{M}_{n}(\mathbb{R})\)</span> 이라 하면,</p>
<p><span class="math display">\[
\boldsymbol{x}^\ast \boldsymbol{Bx} = \boldsymbol{x}^\ast \boldsymbol{A}_n \boldsymbol{x} + d\cdot x^2
\]</span></p>
<p>이다. <span class="math inline">\(\boldsymbol{A}_n\)</span> 이 가정에 의해 positive definite 이며, <span class="math inline">\(d&gt;0\)</span> 이므로 <span class="math inline">\(\boldsymbol{x}^\ast\boldsymbol{Bx}&gt;0\)</span> 이다. 따라서 <a href="#lem-positive_definite" class="quarto-xref">보조정리&nbsp;1</a> 에 의해 <span class="math inline">\(\boldsymbol{B}=\boldsymbol{Q}^\ast\boldsymbol{AQ}\)</span> 일 때 <span class="math inline">\(\boldsymbol{A}\)</span> 는 positive definite 이다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
<p><br></p>
</section>
</section>
<section id="숄레스키-분해" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="숄레스키-분해"><span class="header-section-number">2</span> 숄레스키 분해</h2>
<section id="boldsymbolllast-분해" class="level3">
<h3 class="anchored" data-anchor-id="boldsymbolllast-분해"><span class="math inline">\(\boldsymbol{LL}^\ast\)</span> 분해</h3>
<div class="border" style="background-color:#FFF0F5 ;padding:5px;">
<div id="thm-cholesky_decomposition" class="theorem">
<p><span class="theorem-title"><strong>정리 1</strong></span> Positive definite 행렬 <span class="math inline">\(\boldsymbol{A}\in \mathbb{F}^{n \times n}\)</span> 은 어떤 모든 대각성분이 양수인 하삼각행렬 <span class="math inline">\(\boldsymbol{L} \in \mathbb{F}^{n \times n}\)</span> 에 대해 <span class="math inline">\(\boldsymbol{A}= \boldsymbol{LL}^\ast\)</span> 이다.</p>
</div>
</div>
<p><br></p>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span>수학적 귀납법으로 증명한다. <span class="math inline">\(n=1\)</span> 일 때 경우 <span class="math inline">\(\boldsymbol{A}=\begin{bmatrix}a \end{bmatrix}\)</span> 라면 <a href="#prp-positive_definite_matrix_1" class="quarto-xref">명제&nbsp;3</a> 의 (<span class="math inline">\(4\)</span>) 에 의해 <span class="math inline">\(a&gt;0\)</span> 이므로 <span class="math inline">\(\boldsymbol{L}=\begin{bmatrix} \sqrt{a}\end{bmatrix}\)</span> 이다. <span class="math inline">\(n\)</span> 일때 성립함을 가정하자. <span class="math inline">\(\boldsymbol{A}\in \mathbb{F}^{(n+1)\times (n+1)}\)</span> 에 대해</p>
<p><span class="math display">\[
\boldsymbol{A} = \left[\begin{array}{c|c} \boldsymbol{A}_n &amp; \boldsymbol{b} \\ \hline \boldsymbol{b}^\ast &amp; a\end{array}\right].
\]</span></p>
<p>로 표현 할 수 있다. <span class="math inline">\(\boldsymbol{A}_n = \boldsymbol{L}_n \boldsymbol{L}_n^\ast\)</span> 라면 일 때</p>
<p><span class="math display">\[
\boldsymbol{L} = \left[\begin{array}{c|c} \boldsymbol{L}_n &amp; \boldsymbol{0} \\ \hline \boldsymbol{c}^\ast &amp; d\end{array}\right].
\]</span></p>
<p>라 하자.</p>
<p><span class="math display">\[
\boldsymbol{LL}^\ast = \left[\begin{array}{c|c} \boldsymbol{L}_n\boldsymbol{L}_n^\ast &amp; \boldsymbol{L}_n \boldsymbol{c} \\ \hline (\boldsymbol{L}_n \boldsymbol{c})^\ast &amp; |d|^2\end{array}\right].
\]</span></p>
<p>이므로 <span class="math inline">\(\boldsymbol{b}=\boldsymbol{L}_n \boldsymbol{c}\)</span>, <span class="math inline">\(d+ \boldsymbol{c}^\ast\boldsymbol{c}=|a|^2\)</span> 을 만족하는 <span class="math inline">\(\boldsymbol{c}\)</span> 와 양수 <span class="math inline">\(d\)</span> 가 존재한다면 <span class="math inline">\(\boldsymbol{A} = \boldsymbol{LL}^\ast\)</span> 이다.</p>
<p><span class="math inline">\(\boldsymbol{L}_n\)</span> 이 대각성분이 양수인 하삼각행렬이므로 가역행렬이다. 따라서 <span class="math inline">\(\boldsymbol{c}=(\boldsymbol{L}_n)^{-1} \boldsymbol{b}\)</span> 이다. 따라서 어쨋든 (그것이 양수가 아니고 복소수라고 하더라도) <span class="math inline">\(d=\sqrt{|a|^2-\boldsymbol{c}^\ast \boldsymbol{c}}\)</span> 가 존재하며, <span class="math inline">\(\det(\boldsymbol{A})=|\det(\boldsymbol{L}_n)|^2 d^2 &gt;0\)</span> 로부터 <span class="math inline">\(d^2&gt;0\)</span> 임을 안다. 따라서 <span class="math inline">\(d&gt;0\)</span> 를 얻는다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-Cholesky_decomposition" class="theorem definition">
<p><span class="theorem-title"><strong>정의 4 (숄레스키 분해)</strong></span> <a href="#thm-cholesky_decomposition" class="quarto-xref">정리&nbsp;1</a> 에 따라 Positive definite 행렬 <span class="math inline">\(\boldsymbol{A}\in\mathbb{F}^{n \times n}\)</span> 를 모든 대각성분이 양수인 하삼각 행렬 <span class="math inline">\(\boldsymbol{L}\in \mathbb{F}^{n \times n}\)</span> 에 대해 <span class="math inline">\(\boldsymbol{A}=\boldsymbol{LL}^\ast\)</span> 로 분해하는 것을 <strong>숄레스키 분해 (Cholesky decomposition)</strong> 라고 한다. <span class="math inline">\(\mathbb{F} =\mathbb{R}\)</span> 인 경우 <span class="math inline">\(\boldsymbol{A}=\boldsymbol{LL}^T\)</span> 이므로 <span class="math inline">\(\boldsymbol{LL}^T\)</span> 분해라고도 한다.</p>
</div>
</div>
</div>
</div>
<p><br></p>
</section>
<section id="구현" class="level3">
<h3 class="anchored" data-anchor-id="구현">구현</h3>
<p><span class="math inline">\(\boldsymbol{A},\,\boldsymbol{L}\in \mathbb{F}^{n \times n}\)</span> 을 생각하자. <span class="math inline">\(\boldsymbol{A} = \boldsymbol{LL}^\ast\)</span> 이므로,</p>
<p><span class="math display">\[
\begin{bmatrix} A_{11} &amp; A_{12} &amp; A_{13} &amp; \cdots &amp; A_{1n} \\
A_{21} &amp; A_{22} &amp; A_{23} &amp; \cdots &amp; A_{2n}\\
\vdots &amp; &amp; &amp; &amp; \vdots \\
A_{n1} &amp; A_{n2} &amp; A_{n3} &amp; \cdots &amp; A_{nn}\end{bmatrix}
= \begin{bmatrix} L_{11} &amp; 0 &amp; 0 &amp; \cdots &amp; 0 \\
L_{21}&amp; L_{22} &amp; 0 &amp; \cdots &amp; 0 \\
\vdots &amp; &amp; &amp; &amp; \vdots \\
L_{n1} &amp; L_{n2} &amp; L_{n3} &amp; \cdots &amp; L_{nn} \end{bmatrix}
\begin{bmatrix} L_{11} &amp; \overline{L_{21}} &amp; \overline{L_{31}} &amp; \cdots &amp; \overline{L_{n1}} \\
0 &amp; L_{22} &amp; \overline{L_{32}} &amp; \cdots &amp; \overline{L_{n2}}\\
\vdots &amp; &amp; &amp; &amp; \vdots \\
0 &amp; 0 &amp; 0 &amp; \cdots &amp; \overline{L_{nn}}\end{bmatrix}
\]</span></p>
<p>이다. 또한 <span class="math inline">\(\boldsymbol{L}\)</span> 이 하삼각행렬이므로 다음이 성립한다. <span class="math display">\[
A_{ij} = \boldsymbol{L}_{i:} (\boldsymbol{L}^\ast)_{:j} = \sum_{k=1}^n L_{ik} \overline{L_{jk}} = \sum_{k=1}^{\min (i, j)} L_{ik} \overline{L_{jk}}
\]</span></p>
<p><span class="math inline">\(A_{11}=|L_{11}|^2\)</span>, <span class="math inline">\(A_{i1} =  L_{i1}\overline{L_{11}}=L_{i1}L_{11}\)</span> 이므로 <span class="math inline">\(L_{11}= \sqrt{A_{11}},\, L_{i1} = A_{i1}/L_{11}\)</span> 으로 부터 <span class="math inline">\(\boldsymbol{L}\)</span> 의 1열을 얻을 수 있다. 이제 <span class="math inline">\(\boldsymbol{L}\)</span> 의 <span class="math inline">\(j-1\)</span> 열까지 얻었다고 가정하자.</p>
<p><span class="math display">\[
\begin{aligned}
A_{1, j} &amp; = L_{11}\overline{L_{j1}},\\
A_{i, j} &amp; = \sum_{k=1}^{\min (i, j)} L_{ik}\overline{L_{jk}},
\end{aligned}
\]</span></p>
<p>이다. <span class="math inline">\(i\le j\)</span> 인 경우,</p>
<p><span class="math display">\[
A_{i, j} = L_{i1}\overline{L_{j1}} + \cdots + L_{ii}\overline{L_{ji}}
\]</span></p>
<p>이므로 다음을 얻는다.</p>
<p><span class="math display">\[
\begin{aligned}
\text{if }j \ne i &amp; &amp;L_{ji} &amp;= \dfrac{1}{(\overline{L_{ii}})}\overline{A_{ij} - \sum_{k=1}^{i-1} L_{ik}\overline{L_{jk}}}, \\
&amp; &amp;L_{jj} &amp;= \sqrt{A_{ij}- \sum_{k=1}^{j-1} L_{jk}\overline{L_{jk}}}
\end{aligned}
\]</span></p>
<p>즉 <span class="math inline">\(i\le j\)</span> 일 경우 <span class="math inline">\(L_{ji}\)</span> 는 <span class="math inline">\(\boldsymbol{L}\)</span> 의 <span class="math inline">\(1\)</span> 열부터 <span class="math inline">\(j-1\)</span> 열까지와 <span class="math inline">\(j\)</span> 열의 <span class="math inline">\(1\)</span> 행부터, <span class="math inline">\(j-1\)</span> 행까지의 값을 이용하여 얻을 수 있다. Julia 로 구현한 것은 아래와 같다. 하지만 <code>LinearAlgebra</code> 모듈에 <code>cholesky</code> 함수로 존재하며(그래서 함수 이름을 굳이 <code>mcholesky</code> 로 붙였다), 앞으로 필요하다면 그것을 쓸 것이다.</p>
<p><br></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">mcholesky</span>(A<span class="op">::</span><span class="dt">Matrix{T}</span>) <span class="kw">where</span> T<span class="op">&lt;:</span><span class="dt">Number</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    M <span class="op">=</span> <span class="fu">size</span>(A)[<span class="fl">1</span>]</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    L <span class="op">=</span> <span class="fu">zero</span>(A)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    L[<span class="fl">1</span>, <span class="fl">1</span>] <span class="op">=</span> <span class="fu">sqrt</span>(A[<span class="fl">1</span>, <span class="fl">1</span>])</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span>M</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        L[i, <span class="fl">1</span>] <span class="op">=</span> A[i, <span class="fl">1</span>]<span class="op">/</span>L[<span class="fl">1</span>, <span class="fl">1</span>]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span>M, i <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>j</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> j <span class="op">==</span> i </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>            L[i, i] <span class="op">=</span> <span class="fu">sqrt</span>(A[i, i] <span class="op">-</span> <span class="fu">dot</span>(L[i, <span class="fl">1</span><span class="op">:</span>i<span class="op">-</span><span class="fl">1</span>], L[i, <span class="fl">1</span><span class="op">:</span>i<span class="op">-</span><span class="fl">1</span>]) )</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>            L[j, i] <span class="op">=</span> (A[i, j] <span class="op">-</span> <span class="fu">dot</span>(L[j, <span class="fl">1</span><span class="op">:</span>i<span class="op">-</span><span class="fl">1</span>], L[i, <span class="fl">1</span><span class="op">:</span>i<span class="op">-</span><span class="fl">1</span>]))<span class="op">/</span>L[i, i]</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> L</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><br></p>
</section>
<section id="boldsymbolldlast-분해" class="level3">
<h3 class="anchored" data-anchor-id="boldsymbolldlast-분해"><span class="math inline">\(\boldsymbol{LDL}^\ast\)</span> 분해</h3>
<div class="border" style="background-color:#FFF0F5 ;padding:5px;">
<div id="prp-decomposition_of_lower_triangular_matrix" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 5</strong></span> 대각성분이 모두 <span class="math inline">\(0\)</span> 이 아닌 하삼각 행렬 <span class="math inline">\(\boldsymbol{L}\)</span> 은 어떤 대각행렬 <span class="math inline">\(\boldsymbol{\Delta}\)</span> 와 대각성분이 <span class="math inline">\(1\)</span> 인 하삼각 행렬 <span class="math inline">\(\boldsymbol{\Lambda}\)</span> 에 대해 <span class="math inline">\(\boldsymbol{L}=\boldsymbol{\Lambda}\boldsymbol{\Delta}\)</span> 로 분해된다.</p>
</div>
</div>
<p><br></p>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span><span class="math inline">\(\boldsymbol{\Delta}\)</span> 를 <span class="math inline">\(\boldsymbol{L}\)</span> 의 대각성분만으로 이루어진 대각행렬이라고 하고 <span class="math inline">\(\boldsymbol{\Lambda}\)</span> 를 <span class="math inline">\(\Lambda_{ij} = L_{ij}/\Delta_{ii}\)</span> 라고 하면,</p>
<p><span class="math display">\[
(\boldsymbol{\Lambda \Delta})_{ij} = \sum_{k=1}^i \Lambda_{ik}\Delta_{kj} = L_{ij}
\]</span></p>
<p>이므로 <span class="math inline">\(\boldsymbol{L}=\boldsymbol{\Lambda \Delta}\)</span> 이다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
<p>우리는 positive definite 행렬이 하삼각 행렬과 그 하삼각행렬의 에르미트 conjugarte 의 곱으로 표현된다는 것을 안다(<a href="#thm-cholesky_decomposition" class="quarto-xref">정리&nbsp;1</a>). 여기에 <a href="#prp-decomposition_of_lower_triangular_matrix" class="quarto-xref">명제&nbsp;5</a> 를 같이 생각하면 positive definite 행렬은 어떤 대각행렬이 <span class="math inline">\(1\)</span> 인 하삼각행렬 <span class="math inline">\(\boldsymbol{L}\)</span> 과 대각 행렬 <span class="math inline">\(\boldsymbol{D}_0\)</span> 에 대해</p>
<p><span class="math display">\[
\boldsymbol{A} = (\boldsymbol{LD}_0) (\boldsymbol{LD}_0)^\ast = \boldsymbol{L}(\boldsymbol{D}_0\boldsymbol{D}_0^\ast) \boldsymbol{L}^\ast
\]</span></p>
<p>이다. <span class="math inline">\(\boldsymbol{D}_0\)</span> 는 모든 성분이 양수인 대각행렬이므로 <span class="math inline">\(\boldsymbol{D}=(\boldsymbol{D}_0\boldsymbol{D}_0^\ast)\)</span> 도 그러하다. 따라서 우리는 다음의 결론을 얻을 수 있다.</p>
<div class="border" style="background-color:#FFF0F5 ;padding:5px;">
<div id="prp-LDLt_dcomposition" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 6</strong></span> positive definite 행렬 <span class="math inline">\(\boldsymbol{A}\)</span> 는 어떤 대각성분이 모두 <span class="math inline">\(1\)</span> 인 하삼각 행렬 <span class="math inline">\(\boldsymbol{L}\)</span> 과 대각성분이 모두 양수인 대각행렬 <span class="math inline">\(\boldsymbol{D}\)</span> 에 대해 <span class="math inline">\(\boldsymbol{A} = \boldsymbol{LDL}^\ast\)</span> 로 분해된다.</p>
</div>
</div>
<p><br></p>
</section>
<section id="sec-crout_decompositioni" class="level3">
<h3 class="anchored" data-anchor-id="sec-crout_decompositioni">크라우트 분해</h3>
<p>숄레스키 분해와는 유사한 분해로 크라우트 분해가 있다. <a href="../../src/numerical_analysis_using_julia/04_matrix_algebra.html#sec-pseudodiagonal_matrix">삼중대각행렬</a> 을 하쌍대각행렬 <span class="math inline">\(\boldsymbol{L}\)</span> 과 대각성분이 모두 <span class="math inline">\(1\)</span> 인 상쌍대각행렬 <span class="math inline">\(\boldsymbol{U}\)</span> 의 곱으로 분해하는 것을 <strong>크라우트 분해 (Crount decomposition)</strong> 라고 한다.</p>
<p><br></p>
</section>
</section>
<section id="qr-분해" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="qr-분해"><span class="header-section-number">3</span> QR 분해</h2>
<section id="하우스홀더-행렬" class="level3">
<h3 class="anchored" data-anchor-id="하우스홀더-행렬">하우스홀더 행렬</h3>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-householder_matrix" class="theorem definition">
<p><span class="theorem-title"><strong>정의 5 (하우스홀더 행렬과 하우스홀더 변환)</strong></span> 벡터공간 <span class="math inline">\(\mathbb{C}^n\)</span> 에서의 벡터 <span class="math inline">\(\boldsymbol{v}\)</span> 에 대해 다음과 같이 정의된 <span class="math inline">\(\boldsymbol{H}_v\)</span> 를 <strong>하우스홀더 행렬 (Householder matrix)</strong> 이라 한다.</p>
<p><span id="eq-householder_transformation_1"><span class="math display">\[
\begin{aligned}
\boldsymbol{H}_{\boldsymbol{v}} := I_n- \dfrac{2\boldsymbol{v}\boldsymbol{v}^{\ast}}{\|\boldsymbol{v}\|^2}, \qquad \text{i. e. }\quad
(\boldsymbol{H}_{\boldsymbol{v}})_{ij} := \delta_{ij} - \dfrac{2 v_i \overline{v_j}}{\|\boldsymbol{v}\|^2}.
\end{aligned}
\tag{1}\]</span></span> 여기서 <span class="math inline">\(\boldsymbol{v}\boldsymbol{v}^{\ast}\)</span> 는 벡터의 내적이 아니라 <span class="math inline">\(n\times 1\)</span> 행렬 <span class="math inline">\(\boldsymbol{v}\)</span> 와 <span class="math inline">\(1 \times n\)</span> 행렬 <span class="math inline">\(\boldsymbol{v}^{\ast}\)</span> 가 곱해진 <span class="math inline">\(n \times n\)</span> 행렬을 의미한다. 벡터 <span class="math inline">\(\boldsymbol{x}\in \mathbb{C}^n\)</span> 에 대해 <span class="math inline">\(\boldsymbol{H}_{\boldsymbol{v}} \boldsymbol{x}\in \mathbb{C}^n\)</span> 을 <strong>하우스홀더 변환</strong> 이라 한다. <span class="math inline">\(\boldsymbol{v}\)</span> 가 단위벡터일 경우, 즉 <span class="math inline">\(\|\boldsymbol{v}\|=1\)</span> 라면 좀 더 간단하게 쓸 수 있다.</p>
<p><span id="eq-householder_transformation_2"><span class="math display">\[
\boldsymbol{H}_{\boldsymbol{v}} = I_n- 2\boldsymbol{v}\boldsymbol{v}^{\ast},\qquad \text{where } \|\boldsymbol{v}\|=1.
\tag{2}\]</span></span></p>
</div>
</div>
</div>
</div>
<p><br></p>
<div class="border" style="background-color:#FFF0F5 ;padding:5px;">
<div id="prp-perperties_of_householder_matrix" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 7</strong></span> 하우스홀더 행렬 <span class="math inline">\(\boldsymbol{H}_{\boldsymbol{v}} \in \mathbb{C}^{n \times n}\)</span> 은 다음의 특징을 가진다.</p>
<p>  (<span class="math inline">\(1\)</span>) 에르미트 행렬이다. 즉 <span class="math inline">\(\boldsymbol{H}_{\boldsymbol{v}}=  \boldsymbol{H}_{\boldsymbol{v}}^\ast\)</span>.</p>
<p>  (<span class="math inline">\(2\)</span>) 유니타리 행렬이다. 즉 <span class="math inline">\(\boldsymbol{H}_{\boldsymbol{v}} (\boldsymbol{H}_{\boldsymbol{v}})^\ast = I\)</span>.</p>
</div>
</div>
<p><br></p>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span>(<span class="math inline">\(1\)</span>) <span class="math inline">\(\boldsymbol{v}\)</span> 가 단위벡터일 경우에만 보여도 된다. <span class="math inline">\(\boldsymbol{H} = \boldsymbol{H}_{\boldsymbol{v}}\)</span> 라 하면,</p>
<p><span class="math display">\[
(\boldsymbol{H}^\ast)_{ij} = \overline{H_{ji}}= \delta_{ij}-2 \overline{v_j \overline{v_i}} = \delta_{ij}-2 v_i \overline{v_j} = (\boldsymbol{H})_{ij}
\]</span></p>
<p>이므로 <span class="math inline">\(\boldsymbol{H}_{\boldsymbol{v}}\)</span> 는 에르미트 행렬이다.</p>
<p>(<span class="math inline">\(2\)</span>) 또한,</p>
<p><span class="math display">\[
\begin{aligned}
\left(\boldsymbol{H} (\boldsymbol{H}^\ast)\right)_{ij} &amp;= \left((\boldsymbol{H})^2\right)_{ij} = \sum_{k}(\delta_{ik}-2 v_i \overline{v_k})(\delta_{kj} -2 v_k \overline{v_j}) \\
&amp;= \sum_k \delta_{ik}\delta_{kj} - 2\sum_k \delta_{ik}v_k \overline{v_j} - 2 \sum_k \delta_{kj} v_i \overline{v_k} + 4 \sum_{k} v_i \overline{v_j} v_k \overline{v_k} \\
&amp;= \delta_{ij} - 2 v_i \overline{v_{j}} - 2 v_i \overline{v_j} + 4 v_i \overline{v_j} = \delta_{ij}
\end{aligned}
\]</span></p>
<p>이다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
<div class="border" style="background-color:#FFF0F5 ;padding:5px;">
<div id="cor-perperties_of_householder_matrix" class="theorem corollary">
<p><span class="theorem-title"><strong>따름정리 1</strong></span> 실수성분의 하우스홀더 행렬 <span class="math inline">\(\boldsymbol{H}_{\boldsymbol{v}} \in \mathbb{R}^{n\times n}\)</span> 은 대칭행렬이며 직교행렬이다.</p>
</div>
</div>
<p><br></p>
<p><br></p>
</section>
<section id="하우스홀더-변환과-하우스홀더-반사" class="level3">
<h3 class="anchored" data-anchor-id="하우스홀더-변환과-하우스홀더-반사">하우스홀더 변환과 하우스홀더 반사</h3>
<p>하우스 홀더 행렬은 유니타리 행렬이므로 하우스홀더 변환은 가역변환이다. <span class="math inline">\(\mathbb{R}^n\)</span> 공간에서 벡터 <span class="math inline">\(\boldsymbol{v}\)</span> 만으로 <span class="math inline">\(\boldsymbol{v}\)</span> 와 수직이며 원점을 지나는 평면이 유일하게 정의될 수 있다. 임의의 벡터 <span class="math inline">\(\boldsymbol{x} \in \mathbb{F}^n\)</span> 에 대해,</p>
<p><span class="math display">\[
\begin{aligned}
(\boldsymbol{H}_{\boldsymbol{v}}\boldsymbol{x})_k &amp;=  x_k - \dfrac{2}{\|\boldsymbol{v}\|^2}  \sum_{j=1}^n v_k \overline{v_j} x_j\\
\boldsymbol{H}_{\boldsymbol{v}}\boldsymbol{x} &amp;= \boldsymbol{x} - 2 \dfrac{\langle \boldsymbol{x},\,  \boldsymbol{v} \rangle \boldsymbol{v}}{\|\boldsymbol{v}\|^2}
\end{aligned}
\]</span></p>
<p>이며, <span class="math inline">\(\boldsymbol{x}\)</span> 의 <span class="math inline">\(\boldsymbol{v}\)</span> 벡터에 대한 projection <span class="math inline">\(\text{Proj}_\boldsymbol{v}\boldsymbol{x}= \langle \boldsymbol{v},\, \boldsymbol{x}\rangle \boldsymbol{v}\)</span> 이므로,</p>
<p><span class="math display">\[
\begin{aligned}
\dfrac{1}{2 }(\boldsymbol{x}+\boldsymbol{H_vx}) &amp;= \boldsymbol{x} - \langle \boldsymbol{v,\,  x}\rangle \boldsymbol{v} = \boldsymbol{x} - \text{Proj}_{\boldsymbol{v}} \boldsymbol{x} \\
\boldsymbol{x}-\boldsymbol{H_vx} &amp;= 2\langle \boldsymbol{v ,\, x} \rangle  \boldsymbol{v} = 2\, \text{Proj}_{\boldsymbol{v}}\boldsymbol{x}
\end{aligned}
\]</span></p>
<p>이다. 즉 <span class="math inline">\(\boldsymbol{x}\)</span> 와 <span class="math inline">\(\boldsymbol{Hx}\)</span> 는 <span class="math inline">\(\boldsymbol{v}\)</span> 에 의해 정의되는 평면에 대해 대칭이다. 이런 이유로 하우스홀더 변환을 하우스홀더 반사(Householder reflection) 라고도 한다.</p>
<div id="fig-householder_reflection" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-householder_reflection-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="figure/fig-householder.png" class="img-fluid figure-img" width="300">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-householder_reflection-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
그림&nbsp;1: Householder 반사
</figcaption>
</figure>
</div>
<p><span class="math inline">\(\boldsymbol{x}\)</span> 를 <span class="math inline">\(\boldsymbol{v}\)</span> 와 평행한 부분과 수직한 부분으로 분리하자. 즉 <span class="math inline">\(\boldsymbol{x}_{\|} = \text{Proj}_{\boldsymbol{v}}\boldsymbol{x}\)</span>, <span class="math inline">\(\boldsymbol{x}_{\perp} = \boldsymbol{x}-\text{Proj}_{\boldsymbol{v}}\boldsymbol{x}\)</span> 라 하면, <span class="math inline">\(\boldsymbol{x} = \boldsymbol{x}_{\|} + \boldsymbol{x}_{\perp}\)</span> 이며 <span class="math inline">\(\boldsymbol{x}\cdot \boldsymbol{v} = \boldsymbol{x}_{\|}\cdot \boldsymbol{v}\)</span> 이다.</p>
<p><span class="math display">\[
\boldsymbol{H}_{\boldsymbol{v}}\boldsymbol{x} = \boldsymbol{x} - 2 \boldsymbol{x}_{\|} = \boldsymbol{x}_{\perp} - \boldsymbol{x}_{\|}
\]</span></p>
<p>이다.</p>
<p><br></p>
</section>
<section id="실벡터-공간에서의-하우스홀더-변환과-qr-분해" class="level3">
<h3 class="anchored" data-anchor-id="실벡터-공간에서의-하우스홀더-변환과-qr-분해">실벡터 공간에서의 하우스홀더 변환과 QR 분해</h3>
<p><span class="math inline">\(\boldsymbol{x}_1,\ldots,\,\boldsymbol{x}_n\in \mathbb{R}^n\)</span> 에 대해 <span class="math inline">\(\boldsymbol{X}=\begin{bmatrix} \boldsymbol{x}_1 &amp; \cdots &amp;\boldsymbol{x}_n\end{bmatrix}\)</span> 라고 하자. <span class="math inline">\(\mathbb{R}^n\)</span> 에서의 벡터 <span class="math inline">\(\boldsymbol{x}\)</span> 과 표준 기저 <span class="math inline">\(\{\hat{\boldsymbol{e}}_1,\ldots,\,\hat{\boldsymbol{e}}_n\}\)</span> 를 생각하자. 이 때 <span class="math inline">\(\boldsymbol{v}_1\)</span> 을 다음과 같이 정한다.</p>
<p><span class="math display">\[
\boldsymbol{v}_1 : = \boldsymbol{x}_1-\|\boldsymbol{x}_1\|_2\hat{\boldsymbol{e}}_1
\]</span></p>
<p>그리고 <span class="math inline">\(\boldsymbol{Q}_1 = \boldsymbol{H}_{\boldsymbol{v}_1}\)</span> 이라고 하자. <span class="math inline">\(\boldsymbol{Q}_1\boldsymbol{x_1} = \|\boldsymbol{x}_1\|_2 \hat{\boldsymbol{e}}_1\)</span> 이므로,</p>
<p><span class="math display">\[
\boldsymbol{Q}_1\boldsymbol{X} = \begin{bmatrix} \|\boldsymbol{x}_1\|_2 &amp; x'_{12} &amp; \cdots &amp; x'_{1n} \\ 0 &amp; x'_{22} &amp; \cdots &amp; x'_{2n}  \\  \vdots  &amp; \vdots &amp; \cdots &amp; \vdots  \\ 0 &amp; x'_{n2} &amp; \cdots &amp; x'_{nn}  \end{bmatrix}
\]</span></p>
<p>가 된다. 하우스홀더 행렬의 정의에 의해 <span class="math inline">\(\boldsymbol{v}_1\)</span> 을 <span class="math inline">\(0\)</span> 이 아닌 상수로 나누어 주어도 하우스홀더행렬에는 변화가 없는데 보통 하우스홀더 행렬의 맨 앞 성분을 <span class="math inline">\(1\)</span> 로 만드는 것이 좋다고 한다(<span class="citation" data-cites="golub2013matrix">Golub and Van Loan (<a href="#ref-golub2013matrix" role="doc-biblioref">2013</a>)</span>, pp.235). 여기서 문제가 되는게 만약 <span class="math inline">\(\boldsymbol{x}_1\)</span> 이 첫번째 성분을 제외한 성분이 모두 <span class="math inline">\(0\)</span> 이고 첫번째 성분이 양수라면 <span class="math inline">\(\boldsymbol{v}_1 = \boldsymbol{0}\)</span> 이 되며 이 경우 정규화 할수 없기 때문에 문제가 된다. 즉 코드에 <span class="math inline">\(\boldsymbol{v}/\|\boldsymbol{v}\|_2\)</span> 가 들어가는데 <span class="math inline">\(\|\boldsymbol{v}\|_2=0\)</span> 이므로 <span class="math inline">\(0\)</span> 으로 나누어지는 에러가 발생한다. 이 때는 하우스 홀더 행렬을 <span class="math inline">\(\boldsymbol{I}\)</span>, <span class="math inline">\(\boldsymbol{v}_1 = \hat{\boldsymbol{e}}_1\)</span> 으로 놓고 계산하면 원하는 결과를 얻을 수 있다.</p>
<p>이제 <span class="math inline">\(\boldsymbol{x}'_2 = [x'_{22}, \ldots, x'_{n2}]^T\)</span> (<span class="math inline">\(\boldsymbol{Q}_1\boldsymbol{x}_1\)</span> 의 두번째 행의 두번째 열부터 마지막 열까지로 이루어진 벡터) 를 이용하여 앞의 <span class="math inline">\(\boldsymbol{Q}_1\)</span> 과 같은 과정에서 <span class="math inline">\(\boldsymbol{v}_2\in \mathbb{R}^{n-1}\)</span> 을 정하고 <span class="math inline">\(\boldsymbol{Q}^0_2 = \boldsymbol{H}_{\boldsymbol{v}_2}\in \mathbb{R}^{(n-1) \times (n-1)}\)</span> 을 구성하였다면 당연히 <span class="math inline">\(\boldsymbol{Q}^0_2 \boldsymbol{x}'_2\)</span> 는 첫번째 행을 제외한 나머지 행은 <span class="math inline">\(0\)</span> 일 것이다.</p>
<p><span class="math display">\[
\boldsymbol{Q}_2 = \begin{bmatrix} 1 &amp; \boldsymbol{0}^T \\ \boldsymbol{0} &amp; \boldsymbol{Q}'_2\end{bmatrix}
\]</span></p>
<p>라고 정하자. 그렇다면,</p>
<p><span class="math display">\[
\boldsymbol{Q}_2\boldsymbol{Q}_1 \boldsymbol{X} = \begin{bmatrix} \|\boldsymbol{x}\|_1 &amp; x'_{12} &amp; x'_{13} &amp; \cdots &amp; x'_{1n} \\ 0 &amp; x''_{22} &amp; x''_{23} &amp; \cdots &amp; 0  \\   0 &amp; 0 &amp; x_{33}'' &amp; \cdots &amp; x''_{22} \\ \vdots  &amp; \vdots &amp; \vdots &amp; \cdots &amp; \vdots  \\ 0 &amp; 0 &amp; x'_{n3}  &amp; \cdots &amp; x'_{nn}  \end{bmatrix}
\]</span></p>
<p>이제 <span class="math inline">\(\boldsymbol{x}_3' = \begin{bmatrix} x''_{33} &amp; \cdots &amp; x''_{n3}\end{bmatrix}^T \in \mathcal{M}_{n-2}\)</span> 부터 계속 같은 과정을 반복한다면,</p>
<p><span class="math display">\[
\boldsymbol{Q}_n \cdots \boldsymbol{Q}_1 \boldsymbol{X} = \boldsymbol{R}
\]</span></p>
<p>이 된다. <span class="math inline">\(\boldsymbol{Q}_1,\ldots,\,\boldsymbol{Q}_n\)</span> 은 직교행렬이므로 <span class="math inline">\(\boldsymbol{Q} = (\boldsymbol{Q}_1 \cdots \boldsymbol{Q}_n)^T\)</span> 도 직교행렬이고 따라서</p>
<p><span class="math display">\[
\boldsymbol{X} = \boldsymbol{Q} \boldsymbol{R}
\]</span></p>
<p>이 성립한다.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">house</span>(x<span class="op">::</span><span class="dt">Vector{T}</span>) <span class="kw">where</span> T<span class="op">&lt;:</span><span class="dt">Real</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> <span class="fu">length</span>(x)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    σ <span class="op">=</span> <span class="fu">norm</span>(x[<span class="fl">2</span><span class="op">:</span><span class="kw">end</span>])<span class="op">^</span><span class="fl">2</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    v<span class="op">=</span> [<span class="fl">1</span> ; x[<span class="fl">2</span><span class="op">:</span><span class="kw">end</span>]]</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> σ <span class="op">≈</span> <span class="fu">zero</span>(σ) <span class="op">&amp;&amp;</span> x[<span class="fl">1</span>] <span class="op">≥</span> <span class="fl">0</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        β <span class="op">=</span> <span class="fl">0</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elseif</span> σ <span class="op">≈</span> <span class="fl">0</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        β <span class="op">=</span> <span class="op">-</span><span class="fl">2</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> </span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        μ <span class="op">=</span> <span class="fu">sqrt</span>(x[<span class="fl">1</span>]<span class="op">^</span><span class="fl">2</span><span class="op">+</span>σ)</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> x[<span class="fl">1</span>] <span class="op">≤</span> <span class="fl">0</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>            v[<span class="fl">1</span>] <span class="op">=</span> x[<span class="fl">1</span>] <span class="op">-</span> μ</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> </span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>            v[<span class="fl">1</span>] <span class="op">=</span> <span class="op">-</span>σ<span class="op">/</span>(x[<span class="fl">1</span>]<span class="op">+</span>μ)</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>        β <span class="op">=</span> <span class="fl">2</span><span class="op">*</span>v[<span class="fl">1</span>]<span class="op">^</span><span class="fl">2</span> <span class="op">/</span> (σ <span class="op">+</span> v[<span class="fl">1</span>]<span class="op">^</span><span class="fl">2</span>)</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>        v<span class="op">=</span>v<span class="op">./</span>(v[<span class="fl">1</span>])</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> β, v</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">householder</span>(x<span class="op">::</span><span class="dt">Vector{T}</span>) <span class="kw">where</span> T<span class="op">&lt;:</span><span class="dt">Real</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>    β, v <span class="op">=</span> <span class="fu">house</span>(x)</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> I <span class="op">-</span> β<span class="op">*</span>v<span class="op">*</span>v<span class="op">'</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">qrdecom</span>(mat<span class="op">::</span><span class="dt">Matrix{T}</span>) <span class="kw">where</span> T<span class="op">&lt;:</span><span class="dt">Real</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>    m, n <span class="op">=</span> <span class="fu">size</span>(mat)[<span class="fl">1</span><span class="op">:</span><span class="fl">2</span>]</span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>    <span class="pp">@assert</span> m <span class="op">==</span> n</span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> T<span class="op">&lt;:</span><span class="dt">Integer </span></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>        A <span class="op">=</span> <span class="fu">Float64</span>.(mat[<span class="op">:</span>, <span class="op">:</span>])</span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> </span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>        A <span class="op">=</span> mat[<span class="op">:</span>, <span class="op">:</span>]</span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>    elt <span class="op">=</span> <span class="fu">eltype</span>(A)</span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>    Q <span class="op">=</span> <span class="fu">Matrix</span><span class="dt">{elt}</span>(I, n, n)</span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>(n)</span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>        Hm <span class="op">=</span> <span class="fu">householder</span>(A[i<span class="op">:</span><span class="kw">end</span>, i])</span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">==</span> <span class="fl">1</span> </span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>            Q<span class="op">=</span>Hm</span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a>            A <span class="op">=</span> Q<span class="op">*</span>A</span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a>            X<span class="op">=</span> [<span class="fu">Matrix</span><span class="dt">{elt}</span>(I, i<span class="op">-</span><span class="fl">1</span>, i<span class="op">-</span><span class="fl">1</span>) <span class="fu">zeros</span>(elt, i<span class="op">-</span><span class="fl">1</span>, n<span class="op">-</span>i<span class="op">+</span><span class="fl">1</span>); <span class="fu">zeros</span>(elt, i<span class="op">-</span><span class="fl">1</span>, n<span class="op">-</span>i<span class="op">+</span><span class="fl">1</span>)<span class="ch">'  Hm] </span></span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a>            Q <span class="op">=</span> X<span class="op">*</span> Q</span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a>            A <span class="op">=</span> X<span class="op">*</span>A</span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a>        <span class="kw">end</span></span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end</span></span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a>    return Q<span class="op">'</span>, A</span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><br></p>
<!-- ### 하우스홀더 변환과 QR 분해


$\mathcal{M}_n (\mathbb{F})$ 에서의 벡터 $\bf{x}$ 과 표준 기저 $\{\hat{\bf{e}}_1,\ldots,\,\hat{\bf{e}}_n\}$ 를 생각하자. $\alpha$ 를 $\bf{x}$ 의 첫번째 성분 $x_1 = re^{i\theta}$ 에 대해 다음과 같이 정의한다.

$$
\alpha = \left\{ \begin{array}{ll} \|\bf{x}\|_2  & \text{where } \mathbb{F}=\mathbb{R}, \\ e^{i\theta}\|\bf{x}\|_2 \qquad & \text{where } \mathbb{F} =\mathbb{C}. \end{array} \right.
$$

$\bf{x}$ 에 대해 $\bf{v}$ 를 다음과 같이 정하자. 

$$
\bf{v} = \bf{x} - \alpha \hat{\bf{e}}_1, \\
$$

이렇게 정해진 $\bf{v}$ 를 **하우스홀더 벡터(householder vector)** 라고 한다. 이 때 $\bf{x}$ 의 $\bf{v}$ 에 대한 하우스홀더 변환 $\bf{H}_{\bf{v}}\bf{x}$ 는 다음과 같다. (증명은 연습문제에)

$$
\bf{H}_{\bf{v}}\bf{x} = \bf{x}-\bf{v} = \alpha \hat{\bf{e}}_1.
$$ {#eq-householder_vector}

</br>

@eq-householder_transformation_1 에서 보듯이 $\bf{v}$ 에 스칼라곱을 해도 하우스홀더 변환은 변하지 않는다. 실제로 계산을 위해서는 주어진 $\bf{v}$ 에 대해 $\overline{\bf{v}}=\dfrac{1}{v_1}\bf{v}$ 를 사용하여 변환을 하게되며 $\overline{v}_1=1$ 이 된다. 

</br>

<div class="border" style="background-color:#F2F4F4;padding:5px;">

::: {#thm-qr_decomposition_1}

$\bf{A}\in \mathcal{M}_{m \times n}(\mathbb{F})$ 일 때 어떤 isometry $\bf{Q}\in \mathcal{M}_{m \times m}(\mathbb{F})$ 와 상삼각 행렬 $\bf{R}\in \mathcal{M}_{m \times n}(\mathbb{F})$ 에 대해 $\bf{A}=\bf{QR}$ 이다.

:::

</div></br>

::: {.proof}

하우스홀더 행렬은 isometry 이며 에르미트 행렬임을 생각하자. $n$ 에 대한 induction 으로 증명한다. 

$n=1$ 일 경우 $\bf{x}=\bf{A}$ 라고 하면  $\bf{Q} = \bf{H}[\bf{x}]$ 에 대해 $\bf{QA}=\bf{R}$ 은 2 행부터의 값이 $0$ 인 $m \times 1$ 행렬이다. $\bf{A}=\bf{Q}^\ast \bf{R} = \bf{QR}$ 이므로 $n=1$ 일 때 성립한다. 

이제 $n$ 보다 작거나 같은 자연수에 대해 성립함을 가정하자. $\bf{A}_1\in \mathcal{M}_{m\times n}(\mathbb{F})$ 와 $\bf{a}\in \mathcal{M}_{m\times 1}(\mathbb{F})$ 에 대해 $\bf{A}= \begin{bmatrix} \bf{A}_1 & \bf{a} \end{bmatrix}\in \mathcal{M}_{m \times (n+1)}(\mathbb{F})$ 이다. Induction 의 가정에 의해 $\bf{A}_1 = \bf{Q}_1\bf{R}_1$ 을 만족하는 isometry $\bf{Q}_1\in \mathcal{M}_{m \times m}(\mathbb{F})$ 와 상삼각 행렬 $\bf{R}_1 \in \mathcal{M}_{m \times n}(\mathbb{F})$ 이 존재한다. $m > n$ 일 경우 $n$ 보다 큰 $\bf{R}_1$ 의 행벡터는 모두 영벡터이다.


$\bf{a}$ 에 대해 $\bf{w} = \bf{Q}_1^\ast\bf{a}$ 라고 하자. $\bf{Q}_1\in \mathcal{M}_{m \times m}(\mathbb{F})$ 이다. $\bf{w}$ 는 첫행을 제외한 나머지 행이 $0$ 인 열벡터이다. 이제 $\bf{w}$ 의 $1$ 행부터 $n$ 행까지를 $\bf{w}_1$, $n+1$ 행부터 $m$ 행 까지를 $\bf{w}_2$ 라고 하자. $\bf{w}_2$ 에 대해 $\bf{w}_2 = \bf{Q}_2 \bf{r}_2$ 를 만족하는 $\bf{Q}_2 \in \mathcal{M}_{(m - n)\times (m - n)}(\mathbb{F})$, $\bf{r}_2\in \mathcal{M}_{(m-n)}(\mathbb{F})$ 가 존재한다. 

이제  $\bf{A}_1=\bf{Q}_1\bf{R}_1$ 이며 $\bf{Q}_1$ 은 $n \times n$ isomegtry 이고 $\bf{R}_1$ 은 $m \times n$ 상삼각행렬이라고 하자. 

$$
\bf{Q} = \bf{Q}_1 \begin{bmatrix} \bf{I}_{n} & \bf{0} \\ \bf{0} & \bf{Q}_2\end{bmatrix}
$$

이라 하면, 

$$
\bf{Q} \left[\begin{array}{c|c} \bf{R}_1 & \begin{array}{c}  \bf{w}_1 \\ \bf{r}_2 \end{array} \end{array}\right]=\bf{Q}_1 \left[\begin{array}{c|c} \bf{R}_1 & \begin{array}{c}  \bf{w}_1 \\ \bf{Qr}_2 \end{array} \end{array}\right] = \bf{A}
$$

이다. 




:::


</br>

이미 설명한 그람 슈미트 방법과 유사하게


이제 $\bf{Q}_1= \bf{Q},\, \bf{A}=\bf{A}_1$ 이라 놓으면, 

$$
\bf{Q}_1\bf{A}_1 = \begin{bmatrix}\alpha _{1} & \ast &\cdots &\ast \\0 & & &\\ \vdots & & \bf{A}_2 & \\ 0 & & & \end{bmatrix}
$$

꼴이 된다. 이제 행렬 $m \times n$ 행렬 $\bf{A}_k$ 가 $k$ 번째 행까지는 상삼각 행렬의 모양을 따른다고 하자. 즉 $j\le k$ 이고 $i>k$ 이면 $(\bf{A}_k)_{ij}=0$ 이라 하자. 이 때 $\bf{A}_k$ 의 $k$ 번째 행부터 $m$ 행, $k$ 번째 열부터 $m$ 열까지를 $\bf{A}'_k$ 라 하고,(julia 로 표현하면 `Ak[k:end, k:end]` 가 될 것이다) 이 $\bf{A}'_k$ 에 대해 앞서 $\bf{A}$ 에 했던 것과 똑같은 과정을 수행하는 하우스홀더 행렬을 $\bf{Q}'_k$ 라 하면 $\bf{Q}'_k \bf{A}'_k$ 는 $\bf{Q}_1\bf{A}_1$ 처럼 첫번째 열에서는 첫번째 행을 제외한 나며지 행의 값이 $0$ 이 된다. 
만약

$$
\bf{Q}_k = \begin{bmatrix} \bf{I}_{k-1} & 0 \\ 0 & \bf{Q}_k'\end{bmatrix}
$$

이라 하면, $(k-1)\times (k-1)$ 단위행렬 $I_{k-1}$ 과 $\bf{A}_k$ 를 $k$ 행 과 $k$ 열 부터 잘라 $\bf{A}_{k} = \begin{bmatrix} B_{k} & C_{k} \\ 0 &\bf{A}'_{k}\end{bmatrix}$  로 만들자. $B_k$ 는 $(k-1) \times (k-1)$ 행렬이며 $\bf{A}'_{k}$ 는 $(m-k+1)\times (n-k+1)$ 행렬이다. $\bf{A}_k$ 가 $k$ 열까지 상삼각 행렬 모양이므로 $B_k$ 아래는 $0$ 행렬이다. 두 행렬의 곱은
$$
\bf{Q}_k \bf{A}_k = \begin{bmatrix} \bf{I}_{k-1} & 0 \\ 0 & \bf{Q}_k' \end{bmatrix} \begin{bmatrix} B_{k} & C_{k} \\ 0 &\bf{A}'_{k}\end{bmatrix} = \begin{bmatrix} B_k & C_k \\ 0 & \bf{Q}'_k \bf{A'}_k \end{bmatrix}
$$

이 되고 $\bf{Q}'_k \bf{A}'_k$ 의 첫번째 열은 첫번째 행을 제외하면 모두 $0$ 이므로 $\bf{Q}_k \bf{A}_k$ 는 $k$ 열까지 상삼각 행렬 꼴이 된다.

$L = \min\{m,\,n\}$ 이라 하면 $\bf{Q}_L \bf{Q}_{L-1} \cdots \bf{Q}_1 \bf{A}$ 는 상삼각행렬꼴이 된다. 이를 $\bf{R}$ 이라 하자. $\bf{Q}'_k$ 가 하우스홀더 행렬이므로

$$
\bf{Q}_k \bf{Q}_k^\ast = \begin{bmatrix} \bf{I}_{k-1} & 0 \\ 0 & \bf{Q}_k'\end{bmatrix} \begin{bmatrix} \bf{I}_{k-1} & 0 \\ 0 & (\bf{Q}_k')^\ast\end{bmatrix} = \begin{bmatrix} I_{k-1} & 0 \\0 & \bf{Q}_k' 
(\bf{Q}_k')^\ast\end{bmatrix} = I
$$

이다. 즉 $\bf{Q}_k$ 도 직교행렬이다. $\bf{Q}_k$ 가 에르미트 행렬임은 쉽게 보일 수 있다. 이제,

$$
\bf{Q}_L \cdots \bf{Q}_1 \bf{A} = \bf{R} \implies \bf{A} = \bf{Q}_1^\ast \cdots \bf{Q}_L^\ast \bf{R}
$$

임은 쉽게 보일 수 있다. 직교행렬의 곱은 직교행렬이므로 $\bf{Q}_1^\ast \cdots \bf{Q}_L^\ast$ 도 직교행렬이다. 따라서 QR 분해를 할 수 있다. 


</br>

## 연습문제

::: {#exr-householder-1}

위의 @eq-householder_vector 을 증명하라.

::: 

::: {.solution}

$\alpha \overline{x}_1 = \overline{\alpha}x_1 = |x_1| \|\bf{x}\|_2$ 이며 $|\alpha|^2 = \|\bf{x}\|_2^2$ 이다. $a=\alpha\overline{x}_1=\overline{\alpha}x_1$ 이라 놓고 다음을 계산해 보자. 
$$
\begin{aligned}
\langle \bf{x},\,\bf{v}\rangle & = \langle \, \bf{x} , \bf{x}-\alpha \hat{\bf{e}}_1\rangle = \|\bf{x}\|_2^2-\overline{\alpha} x_1  = \|\bf{x}\|_2^2 - a\\
\langle \bf{v},\,\bf{v}\rangle &= \langle \bf{x} -\alpha \bf{e}_1,\, \bf{x} -\alpha \hat{\bf{e}}_1 \rangle  = \|\bf{x}\|^2 - \overline{\alpha} x_1 -\alpha \overline{x_1} + |\alpha|^2 = 2(\|\bf{x}\|_2^2 -a) \\
&= 2 \langle \bf{x},\, \bf{v} \rangle
\end{aligned}
$$

이므로, (잠시 $\|\bf{x}\|_2$ 를 $\|\bf{x}\|$ 라 하자.)

$$
\bf{H}_\bf{v} \bf{x} = \bf{x} - 2\dfrac{\langle \bf{x},\, \bf{v}\rangle}{\|\bf{v}\|^2} \bf{v} = \bf{x}-\bf{v} = \alpha \hat{\bf{e}}_1
$$

이다. 

::: -->
</section>
<section id="복소벡터공간에서의-qr-분해" class="level3">
<h3 class="anchored" data-anchor-id="복소벡터공간에서의-qr-분해">복소벡터공간에서의 QR 분해</h3>
<p><br></p>
</section>
</section>
<section id="linearalgebra.jl" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="linearalgebra.jl"><span class="header-section-number">4</span> <code>LinearAlgebra.jl</code></h2>
<p>Julia 공식 메뉴얼의 <a href="https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/#man-linalg-factorizations">Matrix Factorization</a> 에는 <code>LinearAlgebra.jl</code> 에서 지원하는 행렬 분해에 대해 소개하고 있다.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: center;">분해 종류</th>
<th style="text-align: center;">함수</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">숄레스키 분해</td>
<td style="text-align: center;"><code>cholesky()</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(LDL^T\)</span> 분해</td>
<td style="text-align: center;"><code>ldlt()</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">LU 분해</td>
<td style="text-align: center;"><code>lu()</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">QR 분해</td>
<td style="text-align: center;"><code>qr()</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">특이값 분해(SVD)</td>
<td style="text-align: center;"><code>svd()</code></td>
</tr>
</tbody>
</table>
<p>그 외에도 행렬의 분해와 관련된 사항을 자세하게 적어 놓았으니 행렬의 분해에 관련된 일을 해야한다면 공식 문서를 숙독해야 한다.</p>



</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">참고문헌</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-golub2013matrix" class="csl-entry" role="listitem">
Golub, G. H., and C. F. Van Loan. 2013. <em>Matrix Computations</em>. Johns Hopkins Studies in the Mathematical Sciences. Johns Hopkins University Press. <a href="https://books.google.co.kr/books?id=X5YfsuCWpxMC">https://books.google.co.kr/books?id=X5YfsuCWpxMC</a>.
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "복사완료!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "복사완료!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/julia-kaeri\.github\.io\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../../src/numerical_analysis_using_julia/index_part2.html" class="pagination-link" aria-label="수치해석 II">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">수치해석 II</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../../src/numerical_analysis_using_julia/09_iterative_method_for_linear_system.html" class="pagination-link" aria-label="선형방정식과 반복법">
        <span class="nav-page-text">선형방정식과 반복법</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>