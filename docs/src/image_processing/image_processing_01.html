<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.554">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>수치해석과 이미지 처리 - 이미지 프로세싱의 기초</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../src/image_processing/image_processing_02.html" rel="next">
<link href="../../src/image_processing/index.html" rel="prev">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-sidebar docked nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">수치해석과 이미지 처리</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="탐색 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../src/numerical_analysis_using_julia/index_part1.html"> 
<span class="menu-text">수치해석 I</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../src/numerical_analysis_using_julia/index_part2.html"> 
<span class="menu-text">수치해석 II</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="../../src/image_processing/index.html" aria-current="page"> 
<span class="menu-text">영상 처리/토모그래피</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../src/topics/nonlinear_least_square_fit.html"> 
<span class="menu-text">다양한 주제들</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
    <a href="mailto:julia.kaeri@gmail.com" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-envelope"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="사이드바 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../src/image_processing/index.html">영상 처리 기초</a></li><li class="breadcrumb-item"><a href="../../src/image_processing/image_processing_01.html">이미지 프로세싱의 기초</a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="사이드바 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">영상 처리 기초</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="토글 섹션">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/image_processing/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">영상 처리</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/image_processing/image_processing_01.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">이미지 프로세싱의 기초</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/image_processing/image_processing_02.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">푸리에 변환을 이용한 이미지 처리</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/image_processing/image_processing_04.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">허프 변환 및 거리 변환 (Hough &amp; Distance Transform)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/image_processing/image_processing_05.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">이미지 복원 및 재구성</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/image_processing/image_processing_06.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">이미지 분할</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/image_processing/image_processing_07.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">칼라 이미지 처리</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/image_processing/introduction_to_signal_processing.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">디지털 신호처리의 기초</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/image_processing/fourier_transform_for_image_processing.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">푸리에 변환</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">
 <span class="menu-text">푸리에 변환과 웨이블릿 변환</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="토글 섹션">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/image_processing/wavelet/fourier_transform.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">푸리에 변환</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/image_processing/wavelet/wavelet_transform.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">웨이블릿 변환</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/image_processing/wavelet/descrete_wavelet_transform.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">이산 웨이블릿 변환</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/image_processing/wavelet_and_image.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">웨이블릿 변환을 이용한 이미지 처리</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/image_processing/wavelet/wavelets_julia.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Wavelets.jl</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true">
 <span class="menu-text">주제별 처리</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true" aria-label="토글 섹션">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/image_processing/tomography.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">토모그래피</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul>
  <li><a href="#소개" id="toc-소개" class="nav-link active" data-scroll-target="#소개"><span class="header-section-number">1</span> 소개</a>
  <ul class="collapse">
  <li><a href="#이미지" id="toc-이미지" class="nav-link" data-scroll-target="#이미지"><span class="header-section-number">1.1</span> 이미지</a></li>
  <li><a href="#여기서" id="toc-여기서" class="nav-link" data-scroll-target="#여기서"><span class="header-section-number">1.2</span> 여기서</a></li>
  </ul></li>
  <li><a href="#점-기준-이미지-가공" id="toc-점-기준-이미지-가공" class="nav-link" data-scroll-target="#점-기준-이미지-가공"><span class="header-section-number">2</span> 점 기준 이미지 가공</a>
  <ul class="collapse">
  <li><a href="#sec-ImageProcessing_pixel_inversion" id="toc-sec-ImageProcessing_pixel_inversion" class="nav-link" data-scroll-target="#sec-ImageProcessing_pixel_inversion"><span class="header-section-number">2.1</span> 픽셀 반전법에 의한 이미지 가공</a></li>
  <li><a href="#sec-ImageProcessing-gamma_correction" id="toc-sec-ImageProcessing-gamma_correction" class="nav-link" data-scroll-target="#sec-ImageProcessing-gamma_correction"><span class="header-section-number">2.2</span> <span class="math inline">\(\gamma\)</span>-correction (or <span class="math inline">\(\gamma\)</span>-encoding)</a></li>
  <li><a href="#sec-ImageProcessing_histogram_equalization" id="toc-sec-ImageProcessing_histogram_equalization" class="nav-link" data-scroll-target="#sec-ImageProcessing_histogram_equalization"><span class="header-section-number">2.3</span> 히스토그램 균등화</a></li>
  </ul></li>
  <li><a href="#노이즈-생성" id="toc-노이즈-생성" class="nav-link" data-scroll-target="#노이즈-생성"><span class="header-section-number">3</span> 노이즈 생성</a>
  <ul class="collapse">
  <li><a href="#노이즈-생성-코드" id="toc-노이즈-생성-코드" class="nav-link" data-scroll-target="#노이즈-생성-코드"><span class="header-section-number">3.1</span> 노이즈 생성 코드</a></li>
  </ul></li>
  <li><a href="#기하학적-변환과-보간법" id="toc-기하학적-변환과-보간법" class="nav-link" data-scroll-target="#기하학적-변환과-보간법"><span class="header-section-number">4</span> 기하학적 변환과 보간법</a>
  <ul class="collapse">
  <li><a href="#sec-ImageProcessing_Affine_transform" id="toc-sec-ImageProcessing_Affine_transform" class="nav-link" data-scroll-target="#sec-ImageProcessing_Affine_transform"><span class="header-section-number">4.1</span> 아핀 변환 (Affine transformation)</a></li>
  <li><a href="#원근-변환-perspective-transformation" id="toc-원근-변환-perspective-transformation" class="nav-link" data-scroll-target="#원근-변환-perspective-transformation"><span class="header-section-number">4.2</span> 원근 변환 (Perspective transformation)</a></li>
  <li><a href="#sec-ImageProcessing_interpolation" id="toc-sec-ImageProcessing_interpolation" class="nav-link" data-scroll-target="#sec-ImageProcessing_interpolation"><span class="header-section-number">4.3</span> 보간법</a></li>
  </ul></li>
  <li><a href="#sec-ImageProcessing_spatial_image_filtering" id="toc-sec-ImageProcessing_spatial_image_filtering" class="nav-link" data-scroll-target="#sec-ImageProcessing_spatial_image_filtering"><span class="header-section-number">5</span> 공간적 이미지 필터링</a>
  <ul class="collapse">
  <li><a href="#sec-ImageProcessing_padding" id="toc-sec-ImageProcessing_padding" class="nav-link" data-scroll-target="#sec-ImageProcessing_padding"><span class="header-section-number">5.1</span> 가장저리 처리</a></li>
  <li><a href="#평균값-필터-mean-filter" id="toc-평균값-필터-mean-filter" class="nav-link" data-scroll-target="#평균값-필터-mean-filter"><span class="header-section-number">5.2</span> 평균값 필터 (mean filter)</a></li>
  <li><a href="#중앙값-필터-median-filter" id="toc-중앙값-필터-median-filter" class="nav-link" data-scroll-target="#중앙값-필터-median-filter"><span class="header-section-number">5.3</span> 중앙값 필터 (median filter)</a></li>
  <li><a href="#표준편차-필터standard-deviation-filter" id="toc-표준편차-필터standard-deviation-filter" class="nav-link" data-scroll-target="#표준편차-필터standard-deviation-filter"><span class="header-section-number">5.4</span> 표준편차 필터(standard deviation filter)</a></li>
  </ul></li>
  <li><a href="#sec-ImageProcessing_convolution_and_correlation" id="toc-sec-ImageProcessing_convolution_and_correlation" class="nav-link" data-scroll-target="#sec-ImageProcessing_convolution_and_correlation"><span class="header-section-number">6</span> 합성곱 개념으로서의 이미지 필터링</a>
  <ul class="collapse">
  <li><a href="#합성곱과-상관값" id="toc-합성곱과-상관값" class="nav-link" data-scroll-target="#합성곱과-상관값"><span class="header-section-number">6.1</span> 합성곱과 상관값</a></li>
  <li><a href="#분리-가능한-필터-커널" id="toc-분리-가능한-필터-커널" class="nav-link" data-scroll-target="#분리-가능한-필터-커널"><span class="header-section-number">6.2</span> 분리 가능한 필터 커널</a></li>
  </ul></li>
  <li><a href="#빈도-필터" id="toc-빈도-필터" class="nav-link" data-scroll-target="#빈도-필터"><span class="header-section-number">7</span> 빈도 필터</a>
  <ul class="collapse">
  <li><a href="#이미지에-있어-빈도-frequency" id="toc-이미지에-있어-빈도-frequency" class="nav-link" data-scroll-target="#이미지에-있어-빈도-frequency"><span class="header-section-number">7.1</span> 이미지에 있어 ‘빈도 (frequency)’</a></li>
  <li><a href="#unsharp-masking-highboost-filtering" id="toc-unsharp-masking-highboost-filtering" class="nav-link" data-scroll-target="#unsharp-masking-highboost-filtering"><span class="header-section-number">7.2</span> Unsharp masking &amp; highboost filtering</a></li>
  <li><a href="#differential-high-pass-filter" id="toc-differential-high-pass-filter" class="nav-link" data-scroll-target="#differential-high-pass-filter"><span class="header-section-number">7.3</span> Differential High-pass Filter</a></li>
  <li><a href="#laplaician-filter" id="toc-laplaician-filter" class="nav-link" data-scroll-target="#laplaician-filter"><span class="header-section-number">7.4</span> Laplaician filter</a></li>
  <li><a href="#laplacian-of-gaussian-filter-log-filter" id="toc-laplacian-of-gaussian-filter-log-filter" class="nav-link" data-scroll-target="#laplacian-of-gaussian-filter-log-filter"><span class="header-section-number">7.5</span> Laplacian of Gaussian Filter (LoG filter)</a></li>
  <li><a href="#위너-필터-wiener-filter" id="toc-위너-필터-wiener-filter" class="nav-link" data-scroll-target="#위너-필터-wiener-filter"><span class="header-section-number">7.6</span> 위너 필터 (Wiener filter)</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../src/image_processing/index.html">영상 처리 기초</a></li><li class="breadcrumb-item"><a href="../../src/image_processing/image_processing_01.html">이미지 프로세싱의 기초</a></li></ol></nav>
<div class="quarto-title">
<h1 class="title">이미지 프로세싱의 기초</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div class="hidden">
<p>% %</p>
%
<p><span class="math display">\[
\DeclarePairedDelimiters{\set}{\{}{\}}
\DeclareMathOperator*{\argmax}{argmax}
\]</span></p>
</div>
<p><br></p>
<section id="소개" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="소개"><span class="header-section-number">1</span> 소개</h2>
<section id="이미지" class="level3" data-number="1.1">
<h3 data-number="1.1" class="anchored" data-anchor-id="이미지"><span class="header-section-number">1.1</span> 이미지</h3>
<ul>
<li>우리의 시각에서 감지하는 바와 같은 2차원 이미지 일 수도 있지만, 측정에서 얻는 2차원 데이터 일 수 도 있다.</li>
<li>여기서 다루는 이미지는 디지털 이미지이다. 정해진 크기의 수로 이루어진 2차원 배열을 이미지라고 통칭한다.</li>
<li>2차원 배열을 <span class="math inline">\(f[i,j]\)</span> 로 표기하며, 행렬과 같이 <span class="math inline">\(i\)</span> 는 세로 방향의 인덱스, <span class="math inline">\(j\)</span> 는 가로 방향의 인덱스이다.</li>
</ul>
<p>프로그래밍에서 2차원 배열의 인덱스는 행렬 표기의 관례를 따라 세로축-가로축 순서이지만, 수학에서 함수로서 표현할 때는 가로축-세로축 순서이다. 이것이 매우 혼동을 일으키지만 이 관례를 계속 사용하기로 한다. 즉</p>
<p><span class="math display">\[
\boxed{
    I[i,\,j]= I(j, i)
}
\]</span></p>
<p>이다.</p>
<p><br></p>
</section>
<section id="여기서" class="level3" data-number="1.2">
<h3 data-number="1.2" class="anchored" data-anchor-id="여기서"><span class="header-section-number">1.2</span> 여기서</h3>
<ul>
<li>Julia 에는 <code>Images.jl</code> 이라는 이미지 처리 라이브러리가 있지만,
<ul>
<li>모든 데이터값을 <span class="math inline">\([0,\,1]\)</span> 사이의 고정 소수(fixed point number) 로 처리하며, 원래 이미지가 가지고 있던 0 부터 255 사이의 부호 없는 정수값을 숨긴다.</li>
<li><a href="https://opencv.org/">opencv</a> 에 비해 기능이 부족하고 무엇보다 느리다.</li>
<li><a href="https://github.com/JuliaImages/OpenCV.jl">OpenCV.jl</a> 이라는 <code>opencv</code> 의 julia 포팅이 있다.</li>
</ul></li>
<li>그런데 <code>OpenCV.jl</code> 은
<ul>
<li>기본 이미지 배열 타입은 <code>OpenCV.Mat</code> 이며 julia 의 <code>Array</code> 와 유사하지만 같지는 않다. <code>Array</code> 에서 사용하는 연산중 많은 것을 사용 할 수 없다. 파이썬의 경우는 <code>opencv2</code> 의 배열은 <code>numpy</code> 의 배열인데…</li>
<li>흑백 이미지라도 <code>OpenCV.Mat</code> 은 3차원 배열이다.</li>
<li><code>OpenCV.Mat</code> 에 대한 연산 (배열간, 배열과 스칼라 사이의 사칙연산을 포함하여) 을 모두 다시 쓰느니 <code>OpenCV.Mat</code> 과 julia <code>Array</code> 사이의 변환 함수를 사용하겠다.</li>
<li><code>OpenCV.Mat</code> 의 배열의 저장 순서는 C++ 이나 파이썬 과 같이 행 우선 방식이지만 Julia 는 열 우선 방식이다. 따라서 변환시 이를 고려해야 한다.</li>
</ul></li>
<li>Julia 의 <a href="https://testimages.juliaimages.org/stable/">TestImages.jl</a> 은 다양한 무료 이미지를 다운로드 받을 수 있도록 해 준다. 여기서의 이미지 처리에 사용하는 이미지는 특별한 언급이 없는 한 여기로부터 얻는다.</li>
</ul>
<p><br></p>
<p><code>OpenCV.jl</code> 을 julia 에서 사용하기 위해 다음과 같은 함수를 사용한다. 앞으로의 모든 코드는</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">OpenCV</span>, <span class="bu">TestImages</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>cv <span class="op">=</span> OpenCV;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Julia Matrix to OpenCV.MAT 변환</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">arr2mat</span>(arr<span class="op">::</span><span class="dt">Matrix{T}</span>) <span class="kw">where</span> T<span class="op">&lt;:</span><span class="dt">Real</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    cv.<span class="fu">Mat</span>(<span class="fu">permutedims</span>(<span class="fu">stack</span>([arr, ]), [<span class="fl">3</span>,<span class="fl">2</span>,<span class="fl">1</span>]))</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Julia Image to Matrix 변환</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">img2arr</span>(img)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    T <span class="op">=</span> <span class="fu">typeof</span>(img[<span class="fl">1</span>, <span class="fl">1</span>].val.i)</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="fu">broadcast</span>(<span class="fu">q-&gt;T</span>(q.val.i),img)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Julia Image to OpenCV.Mat 변환</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">img2mat</span>(img) </span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    T <span class="op">=</span> <span class="fu">typeof</span>(img[<span class="fl">1</span>, <span class="fl">1</span>].val.i)</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    tm <span class="op">=</span> <span class="fu">broadcast</span>(<span class="fu">q-&gt;T</span>(q.val.i),img)</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    cv.<span class="fu">Mat</span>(<span class="fu">permutedims</span>(<span class="fu">stack</span>([tm, ]), [<span class="fl">3</span>,<span class="fl">2</span>,<span class="fl">1</span>]))</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="co"># OpenCV.Mat to Julia Matrix 변환</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">mat2arr</span>(mat<span class="op">::</span><span class="dt">OpenCV.Mat</span>)</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fu">permutedims</span>(mat.data, [<span class="fl">3</span>,<span class="fl">2</span>,<span class="fl">1</span>])</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><br></p>
</section>
</section>
<section id="점-기준-이미지-가공" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="점-기준-이미지-가공"><span class="header-section-number">2</span> 점 기준 이미지 가공</h2>
<ul>
<li><p>각 픽셀 단위의 이미지 처리를 의미한다. 즉 픽셀에 대한 연신이 다른 픽셀의 정보와 독립적으로 이루어진다.</p></li>
<li><p>Gray scale image <span class="math inline">\(I[i, j]\)</span> 를 생각하자. <span class="math inline">\(0\le I[i,\,j] \le 255\)</span> 이다.</p></li>
</ul>
<p><br></p>
<section id="sec-ImageProcessing_pixel_inversion" class="level3" data-number="2.1">
<h3 data-number="2.1" class="anchored" data-anchor-id="sec-ImageProcessing_pixel_inversion"><span class="header-section-number">2.1</span> 픽셀 반전법에 의한 이미지 가공</h3>
<p>상수 <span class="math inline">\(a\)</span> 와 <span class="math inline">\(b&gt;0\)</span> 에 대해 <span class="math display">\[
T_i[I][i, j] = a-b I[i, j],\qquad 0 \le T_i[I] \le 255
\]</span></p>
<p>인 이미지 연산을 픽셀 반전법 이라고 한다. <span class="math inline">\(a=255,\, b=1\)</span> 일 경우 완전한 흑백 반전이다. <code>TestImages.jl</code> 로부터 테스트 이미지를 다운받아 처리하였다.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>img0<span class="op">=</span> <span class="fu">testimage_dip3e</span>(<span class="st">"Fig0108(a) (corn-fluorescence).tif"</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>img1 <span class="op">=</span> <span class="fu">img2arr</span>(img0)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>img2 <span class="op">=</span> (<span class="fu">UInt8</span>(<span class="fl">255</span>) <span class="op">.-</span> img1)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> <span class="fu">arr2mat</span>(<span class="fu">cat</span>(img1, img2;dims<span class="op">=</span><span class="fl">2</span>))</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div id="fig-ImageProcessing_inversion" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-ImageProcessing_inversion-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="notebooks/inversion.jpg" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-ImageProcessing_inversion-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
그림&nbsp;1: 원본 이미지(좌) 와 반전된 이미지
</figcaption>
</figure>
</div>
<p><br></p>
</section>
<section id="sec-ImageProcessing-gamma_correction" class="level3" data-number="2.2">
<h3 data-number="2.2" class="anchored" data-anchor-id="sec-ImageProcessing-gamma_correction"><span class="header-section-number">2.2</span> <span class="math inline">\(\gamma\)</span>-correction (or <span class="math inline">\(\gamma\)</span>-encoding)</h3>
<ul>
<li><p><span class="math inline">\(\gamma&gt;0\)</span> 에 대해 다음과 같이 변환한다. <span class="math display">\[
T_\gamma [I][i, j]  = I[i, j]^\gamma
\]</span></p></li>
<li><p><span class="math inline">\(\gamma\)</span> 값이 <span class="math inline">\(1\)</span> 보다 상당히 크면 픽셀 값이 클수록, <span class="math inline">\(\gamma\)</span> 값이 <span class="math inline">\(1\)</span> 보다 상당히 작으면 픽셀값이 작을수록 대조가 현저해진다.</p></li>
<li><p><span class="math inline">\(0\le I[i,j]\le 255\)</span> 일 때 <span class="math inline">\(\gamma&lt;1\)</span> 이면 <span class="math inline">\(I^\gamma[i, j] &lt; 255\)</span> 이며 <span class="math inline">\(\gamma&gt;1\)</span> 이면 <span class="math inline">\(I^\gamma[i,j]&gt;255\)</span> 일 수 있으므로 최대값이 255가 넘지 않도록 해 준다.</p></li>
<li><p>원본 이미지가 1024x1024 로 크기 때문에 그 크기를 줄여주었다.</p></li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>img0<span class="op">=</span> <span class="fu">testimage_dip3e</span>(<span class="st">"Fig0227(a)(washington_infrared).tif"</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>img1 <span class="op">=</span> cv.<span class="fu">resize</span>(<span class="fu">img2mat</span>(img0), cv.<span class="fu">Size</span><span class="dt">{Int32}</span>(<span class="fl">256</span>, <span class="fl">256</span>))</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>img2 <span class="op">=</span> <span class="fu">arr2mat</span>(<span class="fu">round</span>.(<span class="dt">UInt8</span>, ((img1<span class="op">./</span><span class="fl">255</span>)<span class="op">.^</span><span class="fl">0.5</span>)<span class="op">*</span><span class="fl">255</span>))</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>img3 <span class="op">=</span> <span class="fu">arr2mat</span>(<span class="fu">round</span>.(<span class="dt">UInt8</span>, ((img1<span class="op">./</span><span class="fl">255</span>)<span class="op">.^</span><span class="fl">2</span>)<span class="op">*</span><span class="fl">255</span>))</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>img4 <span class="op">=</span> <span class="fu">arr2mat</span>(<span class="fu">round</span>.(<span class="dt">UInt8</span>, ((img1<span class="op">./</span><span class="fl">255</span>)<span class="op">.^</span><span class="fl">5</span>)<span class="op">*</span><span class="fl">255</span>));</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="fu">arr2mat</span>(<span class="fu">cat</span>(img1, img2, img3, img4; dims<span class="op">=</span><span class="fl">2</span>))</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div id="fig-ImageProcessing_gamma_correction" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-ImageProcessing_gamma_correction-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="notebooks/gamma_correction.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-ImageProcessing_gamma_correction-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
그림&nbsp;2: 맨 왼쪽부터 <span class="math inline">\(\gamma=1\)</span>, <span class="math inline">\(\gamma=0.5\)</span>, <span class="math inline">\(\gamma=2\)</span>, <span class="math inline">\(\gamma=5\)</span>
</figcaption>
</figure>
</div>
<ul>
<li><span class="math inline">\(x\in (0,\,1)\)</span> 에 대해 <span class="math inline">\(\gamma&lt;1\)</span> 이면 <span class="math inline">\(x^\gamma &gt; x\)</span> 이므로 화소 값이 높은 쪽으로 몰린다. 반대로 <span class="math inline">\(\gamma&gt;1\)</span> 이면 <span class="math inline">\(x^\gamma &lt; x\)</span> 이므로 화소 값이 낮은 쪽으로 몰린다.</li>
</ul>
<p><br></p>
</section>
<section id="sec-ImageProcessing_histogram_equalization" class="level3" data-number="2.3">
<h3 data-number="2.3" class="anchored" data-anchor-id="sec-ImageProcessing_histogram_equalization"><span class="header-section-number">2.3</span> 히스토그램 균등화</h3>
<p>이미지의 각 픽셀은 0 에서 255 사이의 정수값을 가진다. 그 값의 빈도는 이미지의 성질을 파악하는데 중요하다. 예를 들어 <a href="#fig-ImageProcessing_gamma_correction" class="quarto-xref">그림&nbsp;2</a> 의 <span class="math inline">\(\gamma\)</span> 에 대한 히스토그램은 다음과 같다.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="co"># opencv 의 calcHist 함수를 julia 에서 쓰기 편하게 변환함.</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">histogram1d</span>(mat<span class="op">::</span><span class="dt">OpenCV.Mat{T}</span>) <span class="kw">where</span> T<span class="op">&lt;:</span><span class="dt">Union{UInt8, UInt16}</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    tm <span class="op">=</span> <span class="fu">Int32</span>(<span class="fu">typemax</span>(T))</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    v <span class="op">=</span> cv.<span class="fu">calcHist</span>(cv.InputArray[mat,], <span class="dt">Int32</span>[<span class="fl">0</span>], <span class="fu">fill</span>(<span class="fu">UInt8</span>(<span class="fl">1</span>), <span class="fu">size</span>(img1)), <span class="dt">Int32</span>[tm<span class="op">+</span><span class="fl">1</span>], <span class="dt">Float32</span>[<span class="fl">0</span>, tm<span class="op">+</span><span class="fl">1</span>])</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (<span class="fl">0</span><span class="op">:</span><span class="fl">1</span><span class="op">:</span>tm, <span class="fu">Int64</span>.(v[<span class="fl">1</span>,<span class="fl">1</span>,<span class="op">:</span>]))    </span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> <span class="fu">Figure</span>()</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> <span class="fu">Axis</span>(fig[<span class="fl">1</span>,<span class="fl">1</span>])</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (img, g) <span class="kw">in</span> <span class="fu">zip</span>([img1, img2, img3, img4], [<span class="fl">1.0</span>, <span class="fl">0.5</span>, <span class="fl">2</span>, <span class="fl">5</span>])</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    b, v <span class="op">=</span> <span class="fu">histogram1d</span>(img)</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="fu">lines!</span>(ax, b, v, label <span class="op">=</span> L<span class="st">"\gamma = %</span><span class="sc">$</span>g<span class="st">"</span>)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a><span class="fu">axislegend</span>()</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>fig</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div id="fig-ImageProcessing_histogram_gamma_correction" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-ImageProcessing_histogram_gamma_correction-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="notebooks/histogram_gamma.png" class="img-fluid figure-img" width="400">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-ImageProcessing_histogram_gamma_correction-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
그림&nbsp;3: <a href="#fig-ImageProcessing_gamma_correction" class="quarto-xref">그림&nbsp;2</a> 의 <span class="math inline">\(\gamma\)</span> 값에 따른 히스토그램
</figcaption>
</figure>
</div>
<p><br></p>
<p>위의 그림에서 <span class="math inline">\(\gamma=5\)</span> 일 때의 히스토그램은 낮은 값으로 몰려 있다. 혹은 이미지 중에는 전체 256 의 채널 갑 중에 어떤 값을 중심으로 몰려 있을 수 있다. 이런 경우 컨트라스트를 조절 하기 위해 앞서의 <span class="math inline">\(\gamma\)</span>-correction 방법으로는 개선이 크게 되지 않는다. 이 때 사용하는 방법이 히스토그램 균등화이다. 한 채널을 중심으로 몰려 있는 히스토그램을 균등화 한다.</p>
<p>원래의 히스토그램을 변수 <span class="math inline">\(r\)</span> 에 대해 <span class="math inline">\(h(r)\)</span> 이며 <span class="math inline">\(r\)</span> 은 <span class="math inline">\(0\)</span> 부터 <span class="math inline">\(L-1\)</span> (여기서는 255) 까지 가질 수 있고 <span class="math inline">\(h(r)\)</span> 확률 별수 <span class="math inline">\(r\)</span> 에 대한 확률 밀도에 비례하는 값이라고 가정하자. <span class="math inline">\(p_r(r)\)</span> 을 확률밀도라고 하면</p>
<p><span id="eq-ImageProcessing_histogram_equalization_1"><span class="math display">\[
p_r(r) = \dfrac{h(r)}{\int_0^L h(r')\,dr'}
\tag{1}\]</span></span></p>
<p>이며 이 때 새로운 변수 <span class="math inline">\(s\)</span> 를 다음과 같이 정의한다.</p>
<p><span id="eq-ImageProcessing_histogram_equalization_2"><span class="math display">\[
s=(L-1)\int_{0}^r p_r(r')\,dr'.
\tag{2}\]</span></span></p>
<p>그렇다면</p>
<p><span id="eq-ImageProcessing_histogram_equalization_3"><span class="math display">\[
\dfrac{ds}{dr} = (L-1)p_r(r)
\tag{3}\]</span></span></p>
<p>이며 새로운 변수 <span class="math inline">\(s\)</span> 로 변환된 <span class="math inline">\(p_r(r)\)</span> 은</p>
<p><span id="eq-ImageProcessing_histogram_equalization_4"><span class="math display">\[
p_s(s) = p_r(r)\left|\dfrac{ds}{dr}\right| = \dfrac{1}{L-1}
\tag{4}\]</span></span></p>
<p>이다. 즉 새로운 변수 <span class="math inline">\(s\)</span> 에 대해 <span class="math inline">\(p_s(s)\)</span> 는 항상 같은 값을 갖게 된다.</p>
<p>즉 어떤 픽셀의 강도가 <span class="math inline">\(r\)</span> 이라면 새로운 강도는 <span class="math inline">\(s\)</span> 가 된다. <span class="math inline">\(r=0,\,1,\ldots,\,L-1\)</span> 의 값을 가지므로 이에 대한 <span class="math inline">\(s\)</span> 값을</p>
<p><span id="eq-ImageProcessing_histogram_equalization_4"><span class="math display">\[
s(r) = \text{round}\left[(L-1)\sum_{i=1}^r \dfrac{h(i)}{\sum_{j=1}^{L-1} h(j)}\right]
\tag{5}\]</span></span></p>
<p>를 이용혜 계산한다. <span class="math inline">\(\text{round}(t)\)</span> 는 <span class="math inline">\(t\)</span> 를 반올림 하는 함수이다. <code>OpenCV</code> 에서는 <code>equalizeHist()</code> 함수로 구현되었으며 여기서는 이 함수를 사용한다.</p>
<p><br></p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="notebooks/equalize_histogram_1.png" class="img-fluid figure-img"></p>
<figcaption>원본, <span class="math inline">\(\gamma=5\)</span> 처리된 이미지, 히스토그램 균등화 된 이미지</figcaption>
</figure>
</div>
<div class="sourceCode" id="cb5"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>img5 <span class="op">=</span> cv.<span class="fu">equalizeHist</span>(img4)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="fu">arr2mat</span>(<span class="fu">cat</span>(img1, img4, img5; dims<span class="op">=</span><span class="fl">2</span>))</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="notebooks/equalize_histogram.png" class="img-fluid figure-img"></p>
<figcaption>원본, <span class="math inline">\(\gamma=5\)</span> 처리된 이미지, 히스토그램 균등화 된 이미지의 히스토그램</figcaption>
</figure>
</div>
<p><br></p>
</section>
</section>
<section id="노이즈-생성" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="노이즈-생성"><span class="header-section-number">3</span> 노이즈 생성</h2>
<p>노이즈의 원인은 다양하며, 노이즈에 대한 처리 방법도 다양하고 매우 중요하다. 일단 가장 빈번하고 다루기 쉬우며 보편적인 두가지 노이즈, 가우시안 노이즈 와 소금-후추 노이즈에 대해 알아보자. 노이즈의 원인은 생각하지 않고 실제 나타나는 양상으로만 분류한다. 또한 한 픽셀에서의 노이즈 발생 확률은 다른 픽셀의 노이즈 발셩 여부와 독립적이라고 가정하자.</p>
<p><br></p>
<p><strong>1. 가우시안 노이즈</strong> : 가우시안 노이즈는 어떤 평균에 대해 가우시안 분포를 갖는 노이즈이다. 즉 노이즈를 생성시키려면 평균값과 표준편차로 정의되는 가우시안 분포에 따라 임의의 점에 대해 생성해야 한다.</p>
<p><strong>2. 소금-후추 노이즈</strong> : 소금은 흰색이고 후추는 검은색이다. 소금-후추 노이즈는 보통 픽셀마다 최저값(0) 혹은 최고값 (<code>UInt8</code> 의 경우는 255) 에 가까운 노이즈가 발생하도록 한다. 흑백 이미지 상에서 최저값은 검은색, 최고값은 흰색으로 관례적으로 표현하기 때문에 노이즈가 마치 이미지에 소금과 후추를 뿌린 것 같다는 의미에서 소금-후추 노이즈라고 불린다.</p>
<p><br></p>
<section id="노이즈-생성-코드" class="level3" data-number="3.1">
<h3 data-number="3.1" class="anchored" data-anchor-id="노이즈-생성-코드"><span class="header-section-number">3.1</span> 노이즈 생성 코드</h3>
<p>흑백 이미지에 대한 노이즈 생성 코드는 다음과 같다.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">Distributions</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">gaussian_noise</span>(img<span class="op">::</span><span class="dt">OpenCV.Mat{T}</span>, μ, σ, N) <span class="kw">where</span> T<span class="op">&lt;:</span><span class="dt">Union{UInt8, UInt16}</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    m, n <span class="op">=</span> <span class="fu">size</span>(img)[<span class="fl">2</span><span class="op">:</span><span class="fl">3</span>]</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    MM <span class="op">=</span> <span class="fu">typemax</span>(T)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    Y, X, V <span class="op">=</span> <span class="fu">rand</span>(<span class="fl">1</span><span class="op">:</span>m, N), <span class="fu">rand</span>(<span class="fl">1</span><span class="op">:</span>n, N), <span class="fu">round</span>.(T, <span class="fu">rand</span>(<span class="fu">truncated</span>(<span class="fu">Normal</span>(μ, σ), <span class="fl">0</span>, MM), N))</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    img2 <span class="op">=</span> <span class="fu">copy</span>(img)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (y, x, v) <span class="op">∈</span> <span class="fu">zip</span>(Y, X, V)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>        img2[<span class="fl">1</span>, y, x] <span class="op">=</span> v</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> img2</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">salt_pepper_noise</span>(img<span class="op">::</span><span class="dt">OpenCV.Mat{T}</span>, N) <span class="kw">where</span> T<span class="op">&lt;:</span><span class="dt">Union{UInt8, UInt16}</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    m, n <span class="op">=</span> <span class="fu">size</span>(img)[<span class="fl">2</span><span class="op">:</span><span class="fl">3</span>]</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    MM <span class="op">=</span> <span class="fu">typemax</span>(T)</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    Y, X, V <span class="op">=</span> <span class="fu">rand</span>(<span class="fl">1</span><span class="op">:</span>m, N), <span class="fu">rand</span>(<span class="fl">1</span><span class="op">:</span>n, N), <span class="fu">sample</span>([<span class="fl">0</span>, MM], N)</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    img2 <span class="op">=</span> <span class="fu">copy</span>(img)</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (y, x, v) <span class="op">∈</span> <span class="fu">zip</span>(Y, X, V)</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>        img2[<span class="fl">1</span>, y, x] <span class="op">=</span> v</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> img2</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>아래 그림은 원본 이미지 <code>testimage("cameraman.tif")</code> 에 대해 가우시안 노이즈와 소금-후추 노이즈를 생성시킨 결과이다.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>img0<span class="op">=</span> <span class="fu">img2mat</span>(<span class="fu">testimage</span>(<span class="st">"cameraman.tif"</span>))</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>img_gn <span class="op">=</span> <span class="fu">gaussian_noise</span>(img0, <span class="fl">100</span>, <span class="fl">10</span>, <span class="fl">10000</span>)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>img_sp <span class="op">=</span> <span class="fu">salt_pepper_noise</span>(img0, <span class="fl">10000</span>)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>img2<span class="op">=</span><span class="fu">arr2mat</span>(<span class="fu">cat</span>([img_gn img_sp]; dims<span class="op">=</span><span class="fl">2</span>))</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div id="fig-ImageProcessing_noise" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-ImageProcessing_noise-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="imgs/noise.png" class="img-fluid figure-img" width="600">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-ImageProcessing_noise-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
그림&nbsp;4: 가우시안 노이즈(왼쪽) 과 소금-후추 노이즈(오른쪽)
</figcaption>
</figure>
</div>
<p>두 이미지의 히스토그램은 다음과 같다. 가우시안 노이즈는 지정한 대로 픽셀값 100 근처에서 가우스 분포를 가지며, 소금-후추 노이즈는 최소값과 최대값에서 발생한다.</p>
<div id="fig-ImageProcessing_noise" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-ImageProcessing_noise-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="notebooks/noise_histogram.png" class="img-fluid figure-img" width="600">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-ImageProcessing_noise-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
그림&nbsp;5: 가우시안 노이즈(왼쪽) 과 소금-후추 노이즈(오른쪽)
</figcaption>
</figure>
</div>
<p><br></p>
</section>
</section>
<section id="기하학적-변환과-보간법" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="기하학적-변환과-보간법"><span class="header-section-number">4</span> 기하학적 변환과 보간법</h2>
<p>영상에서 널리 이용되는 기하학적인 변환에는 아핀 변환(Affine transformation) 과 원근 변환(perspective transformation) 이 있다. 아핀 변환과 투시 변환은 모두 2차원 상의 직선이 직선으로 변환되는 공통점을 가지고 있다. 그러나 서로 평행한 두 직선이 변환 될 때 아핀 변환은 그 평행함이 유지되지만 투시 변환에서는 평행함이 유지되지 않는다.</p>
<div id="fig-ImageProcessing_geometric_transform" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-ImageProcessing_geometric_transform-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="imgs/geometric_transform.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-ImageProcessing_geometric_transform-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
그림&nbsp;6: 이미지의 기하학적 변환
</figcaption>
</figure>
</div>
<p><br></p>
<section id="sec-ImageProcessing_Affine_transform" class="level3" data-number="4.1">
<h3 data-number="4.1" class="anchored" data-anchor-id="sec-ImageProcessing_Affine_transform"><span class="header-section-number">4.1</span> 아핀 변환 (Affine transformation)</h3>
<p>대표적인 아핀 변환으로는 확대, 축소, 회전, 평행이동과 전단 변환등이 있으며, 아핀 변환의 합성도 아핀 변환이다. 아핀 변환은 <span class="math inline">\(3\times 3\)</span> 가역행렬 <span class="math inline">\(\boldsymbol{T}\)</span> 에 의해 정해지는 다음과 같은 변환으로 표현된다. 영상 변환에서는 <span class="math inline">\(2\)</span> 차원 좌표로 <span class="math inline">\(\begin{bmatrix} x &amp; y\end{bmatrix}^T\)</span> 를 사용하지 않고 <span class="math inline">\(\begin{bmatrix}x &amp; y &amp; w \end{bmatrix}^T\)</span> 로 표현되는 소위 <strong>homogeneous coordinate (동차 좌표)</strong> 를 사용한다. <span class="math inline">\(w\)</span> 는 이미지의 스케일에 관련된 값으로 여기서는 우선 <span class="math inline">\(1\)</span> 로 놓을 수 있다. 그리고 변환은 동차 좌표에 대해 수행하며 그 변환 행렬을 <span class="math inline">\(\boldsymbol{T}\)</span> 라고 하자. 그렇다면 다음과 같이 쓸 수 있다.</p>
<p><span class="math display">\[
\begin{bmatrix} x' \\ y' \\1\end{bmatrix} = \boldsymbol{T} \begin{bmatrix} x \\ y \\ 1\end{bmatrix}.
\]</span></p>
<p>예를 들어 <span class="math inline">\(\theta\)</span> 만큼의 반시계 방향 회전 변환 <span class="math inline">\(\boldsymbol{T}_\theta\)</span> 는</p>
<p><span class="math display">\[
\boldsymbol{T}_\theta = \begin{bmatrix} \cos \theta &amp; -\sin \theta &amp; 0 \\ \sin \theta &amp; \cos \theta &amp; 0 \\ 0 &amp; 0 &amp; 1\end{bmatrix}
\]</span></p>
<p>이며 <span class="math inline">\(x\)</span> 방향으로 <span class="math inline">\(d_x\)</span> <span class="math inline">\(y\)</span> 방향으로 <span class="math inline">\(d_y\)</span> 만큼의 이동 변환 <span class="math inline">\(\boldsymbol{T}_\boldsymbol{d}\)</span> 는</p>
<p><span class="math display">\[
\boldsymbol{T}_\boldsymbol{d} = \begin{bmatrix}  1 &amp; 0 &amp; d_x \\ 0 &amp; 1 &amp; d_y \\ 0 &amp; 0 &amp; 1\end{bmatrix}
\]</span></p>
<p>이다. 또한 <span class="math inline">\(x\)</span> 축 혹은 <span class="math inline">\(y\)</span> 축 방향으로 기울이는 <a href="https://en.wikipedia.org/wiki/Shear_mapping">전단 변환(shear tranformation)</a> <span class="math inline">\(\boldsymbol{T}_{Sx},\, \boldsymbol{T}_{Sy}\)</span> 은 각각</p>
<p><span class="math display">\[
\boldsymbol{T}_{Sx} = \begin{bmatrix} 1 &amp; s_x &amp; 0 \\ 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1\end{bmatrix},\qquad \boldsymbol{T}_{Sy} = \begin{bmatrix} 1 &amp; 0 &amp; 0 \\ s_y &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1\end{bmatrix}
\]</span></p>
<p>이다. 또한 <span class="math inline">\(x\)</span> 축 방향으로 <span class="math inline">\(a_x\)</span> 배 만큼, <span class="math inline">\(y\)</span> 축 방향으로 <span class="math inline">\(a_y\)</span> 배 만큼 키우거나 줄이는 변환 <span class="math inline">\(\boldsymbol{T}_c\)</span> 는</p>
<p><span class="math display">\[
\boldsymbol{T}_c = \begin{bmatrix} a_x &amp; 0 &amp; 0 \\ 0 &amp; a_y &amp; 0 \\ 0 &amp; 0 &amp; 1\end{bmatrix}
\]</span></p>
<p>이다.</p>
<p>아핀 변환 행렬 <span class="math inline">\(\boldsymbol{T}\)</span> 는 <span class="math inline">\(2 \times 2\)</span> 행렬 <span class="math inline">\(\boldsymbol{R}\)</span> 과 <span class="math inline">\(2 \times 1\)</span> 행렬 <span class="math inline">\(\boldsymbol{t}\)</span> 에 대해</p>
<p><span class="math display">\[
\boldsymbol{T}=\begin{bmatrix} \boldsymbol{R} &amp; \boldsymbol{t} \\ \boldsymbol{0}^T &amp; 1\end{bmatrix}
\]</span></p>
<p>로 나타 낼 수 있다. <span class="math inline">\(\boldsymbol{R}\)</span> 은 회전이나 전단 변화 같은 기하학적 변형을 나타내는 행렬이고 <span class="math inline">\(\boldsymbol{t}\)</span> 는 평행이동을 나타내는 행렬이다. <span class="math inline">\(\boldsymbol{T}\)</span> 의 역행렬은</p>
<p><span class="math display">\[
\boldsymbol{T}^{-1} = \begin{bmatrix}\boldsymbol{R}^{-1} &amp; -\boldsymbol{R}^{-1}\boldsymbol{t}\\ \boldsymbol{0}^T &amp; 1\end{bmatrix}
\]</span></p>
<p>이다. <span class="math inline">\(\boldsymbol{T}\)</span> 와 <span class="math inline">\(\boldsymbol{T}^{-1}\)</span> 에서 보듯이 <span class="math inline">\(\boldsymbol{T}\)</span> 를 이루는 <span class="math inline">\(\boldsymbol{R}\)</span> 과 <span class="math inline">\(\boldsymbol{t}\)</span> 만으로 아핀 변환과 역변환을 모두 나타낼 수 있으며, OpenCV 의 경우 <span class="math inline">\(2\times 3\)</span> 행렬 <span class="math inline">\(\begin{bmatrix} \boldsymbol{R} &amp; \boldsymbol{t}\end{bmatrix}\)</span> 만으로 2차원 아핀 변환을 나타낸다. 아핀 변환의 미지수는 <span class="math inline">\(\boldsymbol{R}\)</span> 의 행렬 성분 <span class="math inline">\(4\)</span> 개와 <span class="math inline">\(\boldsymbol{t}\)</span> 의 행렬 성분 <span class="math inline">\(2\)</span> 개이며 따라서 6개의 파라미터가 결정되어야 한다. 즉 서로 한 직선상에 위치하지 않은 좌표상의 세 점과 그 점들이 변환되는 점을 안다면 아핀 변환을 결정 할 수 있다.</p>
<p><br></p>
</section>
<section id="원근-변환-perspective-transformation" class="level3" data-number="4.2">
<h3 data-number="4.2" class="anchored" data-anchor-id="원근-변환-perspective-transformation"><span class="header-section-number">4.2</span> 원근 변환 (Perspective transformation)</h3>
<div id="fig-ImageProcessing_example_of_perspective_transformation" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-ImageProcessing_example_of_perspective_transformation-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="https://docs.opencv.org/4.x/homography_source_desired_images.jpg" class="img-fluid figure-img" width="600">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-ImageProcessing_example_of_perspective_transformation-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
그림&nbsp;7: 원근 변환. 출처: https://docs.opencv.org/4.x/d9/dab/tutorial_homography.html
</figcaption>
</figure>
</div>
<p>아핀 변환은 평행선이 평행선으로 유지되는 것과는 달리 원근 변환은 평행선이 평행선으로 유지되지 않는다. 원근 변환은 기본적으로 입체인 피사체를 2차원인 영상으로 변환시킬 때 발생하는 왜곡이다. 우리가 담는 피사체의 각 부분과 카메라 사이의 거리가 다르며, 피사체의 방향과 카메라의 방향에 따라 영상이 변형되기 때문이다. 원본 이미지 <span class="math inline">\(f[i, j]=f(j, i)\)</span> 에 대해 원근 변환은 다음과 같은 변환행렬로 표현 할 수 있다.</p>
<p><span class="math display">\[
\begin{bmatrix} wx' \\ wy' \\ w'\end{bmatrix} =\boldsymbol{P}\begin{bmatrix} x \\ y \\ 1\end{bmatrix},\qquad \text{where }P_{33}=1
\]</span></p>
<p>여기서 <span class="math inline">\(w\)</span> 원본 이미지에 대해 변환된 이미지의 스케일을 정하는 값이다. 원근 변환은 행렬 <span class="math inline">\(\boldsymbol{P}\)</span> 에 의해 결정되며 <span class="math inline">\(P_{33}=1\)</span> 이어야 하므로 모두 8개의 미지수가 존재한다. 따라서 네 점(물론 네 점의 가운데 아무 세점을 골라도 한 직선상이 있지 않아야 한다) 으로 원근 변환을 결정 할 수 있다. 변환된 이미지 <span class="math inline">\(P[f][i', j'] = P[f][wy',\, wx']\)</span> 이다.</p>
<p><br></p>
</section>
<section id="sec-ImageProcessing_interpolation" class="level3" data-number="4.3">
<h3 data-number="4.3" class="anchored" data-anchor-id="sec-ImageProcessing_interpolation"><span class="header-section-number">4.3</span> 보간법</h3>
<p>아핀 변환 혹은 원근 변환 <span class="math inline">\(T\)</span> 에 대해 이미지 <span class="math inline">\(F\)</span> 를 변환시켜 <span class="math inline">\(G=T[F]\)</span> 인 이미지를 얻고자 한다고 하자. 즉 정해진 <span class="math inline">\(i,\,j\)</span> 의 범위에 대해 <span class="math inline">\(G[i,j]\)</span> 전체를 얻어야 한다. <span class="math inline">\(T\)</span> 가 가역변환이므로 <span class="math inline">\(F=T^{-1}[G]\)</span> 이므로 <span class="math inline">\(F[i',\,j'] = T^{-1}[G][i, j]\)</span> 를 통해 <span class="math inline">\(F[i',\,j']\)</span> 의 값으로 <span class="math inline">\(g[i,\,j]\)</span> 를 채울 수 있으면 좋겠지만 <span class="math inline">\(i',\,j'\)</span> 은 대부분 정수가 아니다. 이 때 <strong>보간법(interpolation)</strong> 을 사용하여, <span class="math inline">\(T[G]^{-1}[i,\,j]\)</span> 로 정해지는 <span class="math inline">\((x,\,y)\)</span> 근처의 <span class="math inline">\(F[i,j]\)</span> 값을 이용하여 <span class="math inline">\(G[i,\,j]\)</span> 값을 구한다.</p>
<p><br></p>
<section id="최근접-이웃-보간" class="level4">
<h4 class="anchored" data-anchor-id="최근접-이웃-보간"><strong>최근접 이웃 보간</strong></h4>
<p><span class="math inline">\((x,\,y)\)</span> 에 가장 가까운 정수 값으로 보간하는 것이다. 즉 <span id="eq-ImageProcessing_nearest_neighbor_interpolation"><span class="math display">\[
F(x,\,y) \mapsto F(\text{round}(x),\, \text{round}(y))
\tag{6}\]</span></span></p>
<p>를 사용한다. 가장 간단하면서도 빠르지만 변환된 이미지의 품질이 좋지 못하다.</p>
<p><br></p>
</section>
<section id="이중-선형-보간" class="level4">
<h4 class="anchored" data-anchor-id="이중-선형-보간"><strong>이중 선형 보간</strong></h4>
<p><span class="math inline">\(x,\,y\)</span> 에 대해</p>
<p><span class="math display">\[
i\le y &lt; i+1,\, j\le x&lt;j+1
\]</span></p>
<p>인 정수 <span class="math inline">\(i,\,j\)</span> 를 찾아 <span class="math inline">\(f[i,j]\)</span>, <span class="math inline">\(f[i,j+1]\)</span>, <span class="math inline">\(f[i+1, j]\)</span>, <span class="math inline">\(f[i+1, j+1]\)</span> 인 네 점을 이용한다.</p>
<p><span id="eq-ImageProcessing_bilinear_interpolation"><span class="math display">\[
\begin{aligned}
F(x,\,y) &amp;= (1-x+j)(1-y+i)F(j, i) + (1-x+j)(y-i)F(j,\,i+1) \\[0.3em]
&amp;+ (x-j)(1-y+i)F(j+1, i) + (x-j)(y-i)F(j+1, i+1).
\end{aligned}
\tag{7}\]</span></span></p>
<p>앞서의 최근접 이웃 보간보다는 계산량이 많고 이미지 품질이 좋다.</p>
<p><br></p>
</section>
<section id="이중-큐빅-보간" class="level4">
<h4 class="anchored" data-anchor-id="이중-큐빅-보간"><strong>이중 큐빅 보간</strong></h4>
<p><span class="math inline">\(x,\,y\)</span> 에 대해 <span class="math display">\[
i\le y &lt; i+1,\, j\le x&lt;j+1
\]</span></p>
<p>인 정수 <span class="math inline">\(i,\,j\)</span> 를 찾아 <span class="math inline">\(f[i+k,j+m]\)</span>, <span class="math inline">\(k,\,m = -1,\,0,\,1,\,2\)</span> 인 16개의 점을 이용한다.</p>
<p><span class="math display">\[
d(s) = \left\{\begin{array}{ll} \dfrac{3|s|^3}{2}-\dfrac{5|s|^2}{2}+1, &amp; 0 \le |s| &lt; 1, \\ -\dfrac{|s|^3}{2}+\dfrac{5|s|^2}{2}-4|s|+2, \qquad &amp; 1\le |s|&lt;2 , \\ 0 &amp; |s|&gt;2 \end{array}\right.
\]</span></p>
<p>에 대해 다음 함수를 이용하여 계산한다. <span class="math display">\[
F(x,\,y) = \sum_{k=-1}^2 \sum_{m=-1}^2 F(j+k, i+m)d(x- j-k)d(y - i-m)
\]</span></p>
<p><br></p>
<p>아래 그림은 1차원 데이터의 보간법과 2차원 이미지의 보간법을 설명하는 그림이다.</p>
<div id="fig-ImageProcessing_interpolations" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-ImageProcessing_interpolations-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/90/Comparison_of_1D_and_2D_interpolation.svg/2880px-Comparison_of_1D_and_2D_interpolation.svg.png" class="img-fluid figure-img" width="500">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-ImageProcessing_interpolations-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
그림&nbsp;8: 1차원 및 2차원 보간법(출처 : https://en.wikipedia.org/wiki/Bicubic_interpolation) By <a href="//commons.wikimedia.org/wiki/User:Cmglee" title="User:Cmglee">Cmglee</a> - <span class="int-own-work" lang="en">Own work</span>, <a href="https://creativecommons.org/licenses/by-sa/4.0" title="Creative Commons Attribution-Share Alike 4.0">CC BY-SA 4.0</a>, <a href="https://commons.wikimedia.org/w/index.php?curid=53064904">Link</a>
</figcaption>
</figure>
</div>
<p><br></p>
<p>이제 변환 행렬과 보간법을 사용하여 기하학적으로 이미지를 변환시킬수도, 혹은 변환된 이미지를 복원시킬 수도 있다. 아핀 변환 행렬은 직접 입력할 수도 있고, 원래의 이미지와 변환되는 이미지에서 각 3개(아핀 변환의 경우) 혹은 4개(원근 변환의 경우) 를 선택하여 변환 행렬을 계산 할 수도 있다. 예를 들어 다음과 같이 변환하는 아핀 변환을 생각하자.</p>
<p><span class="math display">\[
[1, 1] \to [4, 5],\qquad [2, 1] \to [5, 6], \qquad [3, 3] \to [4, 2]
\]</span></p>
<p>아핀 변환을 위해서는 변환된 이미지의 크기를 <code>OpenCV.Size{UInt32}</code> 형태의 객체로 전달해야 한다. 이것을 <code>cvSize</code> 함수로 구현하였다.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">cvSize</span>(w<span class="op">::</span><span class="dt">T1</span>, h<span class="op">::</span><span class="dt">T2</span>) <span class="kw">where</span> {T1<span class="op">&lt;:</span><span class="dt">Integer</span>, T2<span class="op">&lt;:</span><span class="dt">Integer</span>}</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> cv.<span class="fu">Size</span>(<span class="fu">Int32</span>(w), <span class="fu">Int32</span>(h))</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>p0 <span class="op">=</span> <span class="dt">Float32</span>[<span class="fl">1</span> <span class="fl">1</span>; <span class="fl">2</span> <span class="fl">1</span>; <span class="fl">3</span> <span class="fl">3</span>]</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>q0 <span class="op">=</span> <span class="dt">Float32</span>[<span class="fl">4</span> <span class="fl">5</span>; <span class="fl">5</span> <span class="fl">6</span>; <span class="fl">4</span> <span class="fl">2</span>]</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>p1, q1 <span class="op">=</span> <span class="fu">arr2mat</span>(p0), <span class="fu">arr2mat</span>(q0)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>H <span class="op">=</span> cv.<span class="fu">getAffineTransform</span>(p1, q1)</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>img1 <span class="op">=</span> cv.<span class="fu">warpAffine</span>(img0, H, <span class="fu">cvSize</span>(<span class="fl">512</span>, <span class="fl">512</span>))</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><code>cv.warpAffine(img0, H, cvSize(512, 512))</code> 는 이미지 <code>img0</code> 를 아핀 변환 행렬 <code>H</code> 를 이용하여폭 512, 높이 512 크기의 이미지로 변환하라는 명령이다.</p>
<p>많이 사용되는 몇몇 변환에 대해서는 아핀 변환 행렬을 얻는 함수가 이미 존재한다. 예를 들어 <code>(cX, cY)</code> 를 중심으로 45도 만큼 회전시키며, 스케일을 0.7 배로 줄이는 변환에 대한 변환행렬은</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>M<span class="op">=</span>cv.<span class="fu">getRotationMatrix2D</span>(<span class="fu">cvPoint</span>(cX, cY), <span class="fl">45.0</span>, <span class="fl">0.7</span>)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>으로 얻을 수 있다. 여기서 <code>cvPoint</code> 함수는 2차원 혹은 3차원 상의 점을 OpenCV 의 <code>OpenCv.Point(x, y)</code> 객체로 반환하는 함수이다.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">cvPoint</span>(x<span class="op">::</span><span class="dt">T1</span>, y<span class="op">::</span><span class="dt">T2</span>) <span class="kw">where</span> {T1<span class="op">&lt;:</span><span class="dt">Real</span>, T2<span class="op">&lt;:</span><span class="dt">Real</span>}</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    T <span class="op">=</span> <span class="fu">promote_type</span>(T1, T2)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> cv.<span class="fu">Point</span><span class="dt">{T}</span>(<span class="fu">T</span>(x), <span class="fu">T</span>(y))</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">cvPoint</span>(x<span class="op">::</span><span class="dt">T1</span>, y<span class="op">::</span><span class="dt">T2</span>, z<span class="op">::</span><span class="dt">T3</span>) <span class="kw">where</span> {T1<span class="op">&lt;:</span><span class="dt">Real</span>, T2<span class="op">&lt;:</span><span class="dt">Real</span>, T3<span class="op">&lt;:</span><span class="dt">Real</span>}</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    T <span class="op">=</span> <span class="fu">promote_type</span>(T1, T2, T3)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> cv.<span class="fu">Point3</span><span class="dt">{T}</span>(<span class="fu">T</span>(x), <span class="fu">T</span>(y), <span class="fu">T</span>(z))</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><br></p>
<p>이를 이용하여 이미지를 45도 회전하고 크기를 0.7배로 줄이는 변환을 수행해보자. 두가지 보간법을 사용하였다.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>h, w <span class="op">=</span> <span class="fu">size</span>(img0)[<span class="fl">2</span><span class="op">:</span><span class="fl">3</span>]</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>cX, cY <span class="op">=</span> <span class="fu">Float32</span>(h<span class="op">/</span><span class="fl">2</span>), <span class="fu">Float32</span>(w<span class="op">/</span><span class="fl">2</span>)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>M <span class="op">=</span> cv.<span class="fu">getRotationMatrix2D</span>(<span class="fu">cvPoint</span>(cX, cY), <span class="fl">45.0</span>, <span class="fl">0.7</span>)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>r1 <span class="op">=</span> cv.<span class="fu">warpAffine</span>(img0, M, <span class="fu">cvSize</span>(w, h), flags<span class="op">=</span>cv.INTER_NEAREST)</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>r2 <span class="op">=</span> cv.<span class="fu">warpAffine</span>(img0, M, <span class="fu">cvSize</span>(w, h), flags<span class="op">=</span>cv.INTER_CUBIC)</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>img3 <span class="op">=</span> <span class="fu">arr2mat</span>(<span class="fu">cat</span>([r1 r2]; dims<span class="op">=</span><span class="fl">2</span>))</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div id="fig-ImageProcessing_image_rotation" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-ImageProcessing_image_rotation-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="notebooks/imgrotate.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-ImageProcessing_image_rotation-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
그림&nbsp;9: 이미지 회전. (왼쪽) 최근접 보간, (오른쪽) 이중 큐빅 보간
</figcaption>
</figure>
</div>
<p>보간법에 따른 이미지가 큰 차이가 보이지 않을 수 도 있지만 이것은 아래에서 좀 더 정확히 보일 것이다.</p>
<p><code>TestImages.jl</code> 로 부터 <span class="math inline">\(256\times 256\)</span> 이미지 <code>cameraman.tif</code> 을 다운 받은 후 <span class="math inline">\(100 \times  100\)</span> 으로 크기를 줄였다. 그리고 그 이미지를 앞서 소개한 세가지 방법으로 확대하였으며 결과는 아래와 같다.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>img0<span class="op">=</span> cv.<span class="fu">resize</span>(<span class="fu">img2mat</span>(<span class="fu">testimage</span>(<span class="st">"cameraman.tif"</span>)), cv.<span class="fu">Size</span><span class="dt">{Int32}</span>(<span class="fl">100</span>, <span class="fl">100</span>))</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>img1 <span class="op">=</span> cv.<span class="fu">resize</span>(img0, cv.<span class="fu">Size</span>(<span class="fu">Int32</span>(<span class="fl">256</span>), <span class="fu">Int32</span>(<span class="fl">256</span>));interpolation<span class="op">=</span> cv.INTER_NEAREST)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>img2 <span class="op">=</span> cv.<span class="fu">resize</span>(img0, cv.<span class="fu">Size</span>(<span class="fu">Int32</span>(<span class="fl">256</span>), <span class="fu">Int32</span>(<span class="fl">256</span>));interpolation<span class="op">=</span> cv.INTER_LINEAR)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>img3 <span class="op">=</span> cv.<span class="fu">resize</span>(img0, cv.<span class="fu">Size</span>(<span class="fu">Int32</span>(<span class="fl">256</span>), <span class="fu">Int32</span>(<span class="fl">256</span>));interpolation<span class="op">=</span> cv.INTER_CUBIC)</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> <span class="fu">arr2mat</span>(<span class="fu">cat</span>(img1, img2, img3; dims<span class="op">=</span><span class="fl">2</span>))</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="notebooks/interpolation.png" class="img-fluid figure-img"></p>
<figcaption>왼쪽부터 최근접 이웃 보간, 이중 선형 보간, 이중 큐빅 보간</figcaption>
</figure>
</div>
<p><br></p>
</section>
</section>
</section>
<section id="sec-ImageProcessing_spatial_image_filtering" class="level2" data-number="5">
<h2 data-number="5" class="anchored" data-anchor-id="sec-ImageProcessing_spatial_image_filtering"><span class="header-section-number">5</span> 공간적 이미지 필터링</h2>
<p>공간적 필터링은 이미지를 2차원 공간으로 간주한다. 어떤 픽셀의 값을 그 주변값의 연산을 통해 바꿔서 원하는 목적을 달성하는 것을 공간적 이미지 필터링 이라고 한다. 많은 경우 2차원 배열을 사용하며 이 배열을 <strong>커널(kernel)</strong> 혹은 <strong>마스크(mask)</strong> 라고 한다. 즉 원본 이미지 <span class="math inline">\(F\)</span> 의 픽셀 <span class="math inline">\([i,\,j]\)</span> 에 대해 부근의 픽셀의 집합 <span class="math inline">\(N_{[i,j]}\)</span> 을 사용하는 어떤 연산 <span class="math inline">\(H\)</span> 가 정의되어 연산된 이미지 <span class="math inline">\(G\)</span> 가 만들어 진다면, 즉</p>
<p><span id="eq-ImageProcessing_spatial_image_filter"><span class="math display">\[
G[i,j] = H\left(N_{[i,j]}\right)
\tag{8}\]</span></span></p>
<p>일 때 이 과정을 공간적 이미지 필터링 이라고 한다. 만약 <span class="math inline">\(G[i,\,j]\)</span> 가 <span class="math inline">\(N_{[i, j]}\)</span> 의 성분들의 선형결합이라면 이 필터를 선형 필터(linear filter) 라고 하며, 그렇지 않다면 비선형 필터라고 한다. 대표적으로 주변 <span class="math inline">\(n\)</span> 개의 픽셀의 평균값을 취하는 평균값 필터가 선형 필터이며, 중간값을 취하는 중간값 필터는 비선형 필터이다. 선형 필터는 다음에 나올 <a href="#sec-ImageProcessing_convolution_and_correlation">합성곱</a>으로 표현 할 수 있다.</p>
<p><br></p>
<section id="sec-ImageProcessing_padding" class="level3" data-number="5.1">
<h3 data-number="5.1" class="anchored" data-anchor-id="sec-ImageProcessing_padding"><span class="header-section-number">5.1</span> 가장저리 처리</h3>
<p>뒤에 나오겠지만 평균값 필터는 이미지의 어떤 픽셀과 그 주변의 선택된 픽셀값과의 평균으로 필셀값을 대체하는 필터이다. 예를 들어 이미지 <span class="math inline">\(f\)</span> 의 <span class="math inline">\([i, j]\)</span> 를 중심으로 하는 <span class="math inline">\(3\times 3\)</span> 정사각형에 속하는 9개의 픽셀값의 평균값으로 필터링 한다면</p>
<p><span class="math display">\[
G[i,\,j]=\frac{1}{9} \sum_{p=-1,\,0,\,1} \sum_{q=-1,\,0,\,1} F[i-p,\,j-q]
\]</span></p>
<p>일 것이다. 노이즈 처리에 사용 될 수 있다. 이 경우 가장자리 라면, 예를 들어 <span class="math inline">\(i=1\)</span> 이면 <span class="math inline">\(i-1\)</span> 픽셀이 없으므로 문제가 된다. 일반적으로 필터링의 범위를 고려하여 필터링에 방해가 되지 않도록 이미지의 크기를 일시적으로 키우고 원본 이미지에 없던 부분을 적당한 값으로 채운 후(이 작업을 <strong>패딩(padding)</strong> 이라고 한다) 그 이미지 <span class="math inline">\(\overline{F}\)</span> 에 대해 필터링을 하고, 필터링이 모두 끝난 후 필터링된 이미지 <span class="math inline">\(\overline{g}\)</span> 를 원본 이미지에 맞게 크기를 줄이게 된다. 패딩을 할 때 특정한 값으로 채울 수도 있고(<strong>상수 패딩(constant padding)</strong>), 가장 가까운 원본 이미지 픽셀값을 복사할 수도 있으며(<strong>복제 패딩(replication padding)</strong>), 패딩되는 픽셀에 가장 가까운 원본 이미지 픽셀을 중심으로 대칭이 되도록 원본 픽셀 값을 복사할 수도 있다(<strong>반사 패딩(reflection padding)</strong>).</p>
<p><br></p>
<div id="fig-ImageProcessing_padding" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-ImageProcessing_padding-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="imgs/padding.png" class="img-fluid figure-img" width="550">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-ImageProcessing_padding-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
그림&nbsp;10: 이미지 패딩
</figcaption>
</figure>
</div>
<p><br></p>
<p>이후로는 이미지 필터를 다룰 때 사용자가 적절한 패딩을 선택했다고 가정한다.</p>
<p><br></p>
</section>
<section id="평균값-필터-mean-filter" class="level3" data-number="5.2">
<h3 data-number="5.2" class="anchored" data-anchor-id="평균값-필터-mean-filter"><span class="header-section-number">5.2</span> 평균값 필터 (mean filter)</h3>
<ul>
<li><a href="https://docs.opencv.org/4.x/d4/d13/tutorial_py_filtering.html">https://docs.opencv.org/4.x/d4/d13/tutorial_py_filtering.html</a> 를 참고하라.</li>
</ul>
<p>노이즈를 줄이고 이미지를 부드럽게 하는 데 사용된다. 필터의 크기는 폭 <code>w</code>, 높이 <code>h</code> 에 대해 <code>cv2.Size(w, h)</code> (즉 여기서는 <code>cvSize(w, h)</code>) 로 결정한다.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>cv.<span class="fu">blur</span>(img0, <span class="fl">3</span>)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div id="fig-ImageProcessing_mean_blur_example" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-ImageProcessing_mean_blur_example-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="notebooks/meanblur_example.png" class="img-fluid figure-img" width="500">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-ImageProcessing_mean_blur_example-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
그림&nbsp;11: 원본 이미지(왼쪽) 와 <span class="math inline">\(5\times 5\)</span> 평균값 필터로 처리된 이미지(오른쪽)
</figcaption>
</figure>
</div>
<p><br></p>
</section>
<section id="중앙값-필터-median-filter" class="level3" data-number="5.3">
<h3 data-number="5.3" class="anchored" data-anchor-id="중앙값-필터-median-filter"><span class="header-section-number">5.3</span> 중앙값 필터 (median filter)</h3>
<p>비선형 필터의 대표적인 필터는 중앙값 필터로 특히 소금-후추 노이즈를 제거하는데 많이 사용된다. 중앙값 필터는 원본 이미지 <code>img</code> 와 커널 크기 <code>ksize</code> 에 대해 <code>OpenCV.medianBlur(img, ksize)</code> 와 같이 사용한다. <code>ksize==3</code> 일 경우 <span class="math inline">\([i, j]\)</span> 를 중심으로하는 <span class="math inline">\(3 \times 3\)</span> 크기의 부분 이미지에 대한 중간값으로 변환시킨다. 앞의 <a href="#fig-ImageProcessing_noise" class="quarto-xref">그림&nbsp;5</a> 의 소금-후추 노이즈 이미지(<code>img_sp</code>) 를 중간값 처리 한 결과는 아래와 같다.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>cv.<span class="fu">medianBlur</span>(img_sp, <span class="fl">3</span>)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div id="fig-ImageProcessing_median_blur_example" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-ImageProcessing_median_blur_example-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="notebooks/medianblur_example.png" class="img-fluid figure-img" width="500">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-ImageProcessing_median_blur_example-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
그림&nbsp;12: 소금 후추 노이즈 이미지(왼쪽) 과 중간값 필터로 처리된 이미지(오른쪽)
</figcaption>
</figure>
</div>
<p><br></p>
</section>
<section id="표준편차-필터standard-deviation-filter" class="level3" data-number="5.4">
<h3 data-number="5.4" class="anchored" data-anchor-id="표준편차-필터standard-deviation-filter"><span class="header-section-number">5.4</span> 표준편차 필터(standard deviation filter)</h3>
<p>표준편차 필터는 주변 픽셀값들의 표준편차로 픽셀값을 변환시킨다. 만약 한 픽셀 주변의 값이 서로 크게 바뀐다면 표준 편차 값이 클 것이다. 한 픽셀 주변 값이 서로 비슷하다면 표준 편차 값이 작을 것이다. 일단 이것을 구현해 보자. 우리는 표준편차가 제곱의 평균값에서 평균값의 제곱을 뺀 값의 양의 제곱근이라는 것을 안다.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>imgx <span class="op">=</span> cv.<span class="fu">Mat</span>(<span class="fu">convert</span>.(<span class="dt">Float32</span>, img0))</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>imgx_sq <span class="op">=</span> cv.<span class="fu">Mat</span>(imgx <span class="op">.*</span> imgx)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>imgx_mu <span class="op">=</span> cv.<span class="fu">blur</span>(imgx, <span class="fu">cvSize</span>(<span class="fl">3</span>, <span class="fl">3</span>))</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>imgx_sqmu <span class="op">=</span> cv.<span class="fu">blur</span>(imgx_sq, <span class="fu">cvSize</span>(<span class="fl">3</span>, <span class="fl">3</span>))</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>imgx_musq <span class="op">=</span> cv.<span class="fu">Mat</span>(imgx_mu <span class="op">.*</span> imgx_mu)</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>img_sdfiltered <span class="op">=</span> cv.<span class="fu">Mat</span>(imgx_sqmu <span class="op">.-</span> imgx_musq)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div id="fig-ImageProcessing_stdfilter_example" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-ImageProcessing_stdfilter_example-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="notebooks/stdfilter_example.png" class="img-fluid figure-img" width="500">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-ImageProcessing_stdfilter_example-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
그림&nbsp;13: 표준편차 필터
</figcaption>
</figure>
</div>
<p>표준편차 필터는 위의 영상처럼 원본 영상 속 피사체의 윤곽을 도드러지게 보여준다.</p>
<p><br></p>
</section>
</section>
<section id="sec-ImageProcessing_convolution_and_correlation" class="level2" data-number="6">
<h2 data-number="6" class="anchored" data-anchor-id="sec-ImageProcessing_convolution_and_correlation"><span class="header-section-number">6</span> 합성곱 개념으로서의 이미지 필터링</h2>
<p>합성곱과 상관값은 공간적 이미지 필터링의 일종이다.</p>
<section id="합성곱과-상관값" class="level3" data-number="6.1">
<h3 data-number="6.1" class="anchored" data-anchor-id="합성곱과-상관값"><span class="header-section-number">6.1</span> 합성곱과 상관값</h3>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-ImageProcessing_convolution_and_correlation" class="theorem definition">
<p><span class="theorem-title"><strong>정의 1 (합성곱과 상관값)</strong></span> 원본 이미지 <span class="math inline">\(F[i,\,j]\)</span> 와 커널 <span class="math inline">\(K[s,\,t]\)</span> (혹은 마스크(mask) 라고도 한다) 을 생각하자. 이 때 커널은 <span class="math inline">\((2a+1)\times (2b+1)\)</span> 크기의 2차원 배열이며 커널 배열의 인덱스는</p>
<p><span class="math display">\[
\begin{aligned}
s:&amp; -a,\, -(a-1),\ldots,\, -1,\,0,\,1,\ldots,\,a-1,\,a, \\
t:&amp;-b,\, -(b-1),\ldots,\, -1,\,0,\,1,\ldots,\,b-1,\,b,
\end{aligned}
\]</span></p>
<p>로 잡는다. 이미지와 커널 사이의 <strong>합성곱(convolution)</strong> <span class="math inline">\(k \ast I\)</span> 와 <strong>상관값(correlation)</strong> <span class="math inline">\(k \otimes I\)</span> 는 각각 다음과 같이 정의된다.</p>
<p><span id="eq-ImageProcessing_definition_of_convolution_and_correlation"><span class="math display">\[
\begin{aligned}
(K \ast F)[i, j] &amp;:= \sum_{s=-a}^{a} \sum_{t=-b}^b K[s,\,t] \,F[i-s,\, j-t],\\[0.3em]
(K \otimes F)[i,j] &amp;:= \sum_{s=-a}^{a} \sum_{t=-b}^b K[s,\,t]\, F[i+s,\, j+t].
\end{aligned}
\tag{9}\]</span></span></p>
</div>
</div>
</div>
</div>
<p><br></p>
<p>우선 상관값을 살펴 보자. 커널이</p>
<p><span class="math display">\[
K = \begin{bmatrix} 1 &amp; 0 &amp; -1 \\ 1 &amp; 0 &amp; -1 \\ 1 &amp; 0 &amp; -1\end{bmatrix}
\]</span></p>
<p>이고 원본 이미지의 <span class="math inline">\(F[i, j]\)</span> 를 중심으로 한 <span class="math inline">\(3\times 3\)</span> 배열이</p>
<p><span class="math display">\[
\tilde{F}_{[i, j]}= F[i-1:i+1, j-1:j+1]= \begin{bmatrix} 4 &amp; 0 &amp; 2 \\ 1 &amp; 0 &amp; 3 \\ 2 &amp; 3 &amp; 1\end{bmatrix}
\]</span></p>
<p>이라면 <span class="math inline">\((K\otimes F)[i, j]\)</span> 는 <span class="math inline">\(K\)</span> 와 <span class="math inline">\(\tilde{F}_{[i, j]}\)</span> 의 성분별 곱의 합으로 정의된다. 즉</p>
<p><span class="math display">\[
(k\otimes I)[i, j] = 1\times 4 + (-1)* 2 + 1 * 1 + (-1)\times 3 + 1 \times 2 + (-1)\times 1 = 1
\]</span></p>
<p>이다. 그러나 합성곱은 <a href="#eq-ImageProcessing_definition_of_convolution_and_correlation" class="quarto-xref">식&nbsp;9</a> 에서 알 수 있듯이 <span class="math inline">\(K\)</span> 의 성분과 대각 위치에 있는 <span class="math inline">\(\tilde{F}_{[i, j]}\)</span> 의 성분의 모든 곱의 합이다. 즉, <span class="math display">\[
(K \ast F)[i, j] = 1\times 2 + (-1)* 4 + 1 * 3 + (-1)\times 1 + 1 \times 1 + (-1)\times 2 = -1
\]</span></p>
<p>이다. 혹은 합성곱은 커널을 180 도 회전시킨 행렬과의 상관값이라고 생각 할 수도 있다. 또 커널과 합성곱의 중요한 차이는 아래 표와 같다.</p>
<div id="tbl-ImageProcessing_convolution_and_correlation" class="quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-ImageProcessing_convolution_and_correlation-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
표&nbsp;1: 합성곱과 상관값의 수학적 성질
</figcaption>
<div aria-describedby="tbl-ImageProcessing_convolution_and_correlation-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table">
<colgroup>
<col style="width: 18%">
<col style="width: 40%">
<col style="width: 40%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">성질</th>
<th style="text-align: center;">합성곱</th>
<th style="text-align: center;">상관값</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">commtative</td>
<td style="text-align: center;"><span class="math inline">\(F\ast G = G \ast F\)</span></td>
<td style="text-align: center;"><span class="math inline">\(-\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">associative</td>
<td style="text-align: center;"><span class="math inline">\(F\ast(G \ast H) = (F \ast G)\ast H\)</span></td>
<td style="text-align: center;"><span class="math inline">\(-\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">distributive</td>
<td style="text-align: center;"><span class="math inline">\(F\ast(G+H)= F\ast G + F \ast H\)</span></td>
<td style="text-align: center;"><span class="math inline">\(F\otimes (G + H) = F\otimes G + F \otimes H\)</span></td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p><br></p>
<p>일반적으로 상관값이 계산량이 적고 직관적인데 비해 합성곱이 수학적으로 좋은 성질을 많이 가지고 있다. 또한 커널이 중심에 대해 대칭이라면 합성곱과 상관값은 동일하다.</p>
<br>
<div class="border" style="background-color:#F2F4F4  ;padding:5px;">
<div id="exm-ImageProcessing_convolution_and_correlation" class="theorem example">
<p><span class="theorem-title"><strong>예제 1</strong></span> <a href="#def-ImageProcessing_convolution_and_correlation" class="quarto-xref">정의&nbsp;1</a> 의 커널 인덱스 표기법을 사용하자. 커널이 <span class="math inline">\(K[-s,\,-t] = K[s,\,t]\)</span> 라면 <span class="math inline">\(K\ast F =  K \otimes F\)</span> 임을 보일 수 있다.</p>
<p><span class="math display">\[
\begin{aligned}
(K \ast F)[i,\,j] &amp;= \sum_{s=-a}^{a} \sum_{t=-b}^b K[s,\,t] \,F[i-s,\, j-t] &amp;&amp;; s\to -s,\, t\to -t \\
&amp;=\sum_{s=-a}^{a} \sum_{t=-b}^b K[-s,\, -t] F[i+s,\, j+t] &amp;&amp;;K[-s,\,-t] = K[s,\,t]\\
&amp;= \sum_{s=-a}^{a} \sum_{t=-b}^b K[s,\, t] F[i+s,\, j+t] \\
&amp;= (K\otimes F)[i, j]
\end{aligned}
\]</span></p>
</div>
</div>
<p><br></p>
<p>가끔 합성곱과 상관값이 서로 혼용되기도 한다. 예를 들어 신경망의 합성곱 신경망(convolutional neural network, CNN) 에서는 실제로 이름에 나온 합성곱 연산이 아닌 상관 연산을 사용한다. 그러나 역사적, 관례적 이유로 합성곱 신경망이라는 이름을 사용한다.</p>
<p><br></p>
</section>
<section id="분리-가능한-필터-커널" class="level3" data-number="6.2">
<h3 data-number="6.2" class="anchored" data-anchor-id="분리-가능한-필터-커널"><span class="header-section-number">6.2</span> 분리 가능한 필터 커널</h3>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<div id="def-ImageProcessing_seperable_kernel" class="theorem definition">
<p><span class="theorem-title"><strong>정의 2 (분리 가능한 커널)</strong></span> 열벡터 <span class="math inline">\(\boldsymbol{v},\, \boldsymbol{w}\)</span> 에 대해 커널 행렬 <span class="math inline">\(\boldsymbol{K}\)</span> 가</p>
<p><span class="math display">\[
\boldsymbol{K}= \boldsymbol{v}\boldsymbol{w}^T
\]</span></p>
<p>의 형태로 쓸 수 있을 때 이 커널을 분리 가능한 커널이라고 한다.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<div class="border" style="background-color:#FFF0F5 ;padding:5px;">
<div id="prp-ImageProcessing_seperable_kernel" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 1</strong></span> <span class="math inline">\(m \times n\)</span> 행렬 <span class="math inline">\(\boldsymbol{K}\)</span> 가 <a href="#def-ImageProcessing_seperable_kernel" class="quarto-xref">정의&nbsp;2</a> 와 같이 분리가능하다면 <span class="math inline">\(\boldsymbol{K} = \boldsymbol{v}\ast \boldsymbol{w}^T\)</span> 이다. 즉 두 벡터의 합성곱이다.</p>
</div>
</div>
<p><br></p>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span><span class="math display">\[
K[i,j] = v_i w_j = v[i, 0] (w^T)[0, j]=\sum_{s=0} \sum_{t=0} v[s, t] w^T[0+s, j+t] = v \ast w^T
\]</span></p>
<p>이므로 <span class="math inline">\(\boldsymbol{K}\)</span> 는 <span class="math inline">\(\boldsymbol{v}\)</span> 와 <span class="math inline">\(\boldsymbol{w}^T\)</span> 의 합성곱이다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
<p><span class="math inline">\(K= v \ast w\)</span> 라면</p>
<p><span class="math display">\[
K \ast f = (v \ast w) \ast f = v \ast (w \ast f)
\]</span></p>
<p>이다. 즉 분리 가능한 커널을 순차적으로 적용시킨 것과 같다. <span class="math inline">\(M \times N\)</span> 이미지 <span class="math inline">\(f\)</span> 에 대해 <span class="math inline">\(m\times n\)</span> 커널 <span class="math inline">\(K\)</span> 를 이용하여 필터링했다면 한 픽셀당 <span class="math inline">\(mn\)</span> 번의 곱셈과 <span class="math inline">\(mn-1\)</span> 번의 덧셈, 그리고 1번의 할당을 수행하며, 이것을 <span class="math inline">\(MN\)</span> 번 수행하므로 모두 <span class="math inline">\(MN(2mn)\)</span> 번의 연산을 수행한다. <span class="math inline">\((w\ast f)\)</span> 연산에는 <span class="math inline">\(MN(2n)\)</span> 번의 연산을 수행하며 이후 <span class="math inline">\(v\)</span> 를 적용하면 <span class="math inline">\(MN(2m)\)</span> 번의 연산을 수행하므로 모두 <span class="math inline">\(MN(2m+2n)\)</span> 번의 연산을 수행한다. 즉 두가지 동일한 결과를 낳는 연산의 연산 횟수 비가</p>
<p><span class="math display">\[
\text{ratio}=\dfrac{Mn(2mn)}{Mn(2m+2n)}= \dfrac{mn}{m+n}
\]</span></p>
<p>이다. <span class="math inline">\(m=n=5\)</span> 일 경우 분리 가능한 커널을 분리하여 사용하는 것이 연산 횟수가 2.5배 줄며 <span class="math inline">\(m=n=11\)</span> 일 경우 5.5 배 줄게 된다. 물론 연산 횟수의 감소가 그만큼의 시간의 절약을 정확하게 의미하지는 않지만 커널이 클 때 분리가능하다면 이 방법을 사용하는 것은 큰 장점이 된다.</p>
<p><br></p>
<div class="border" style="background-color:#FFF0F5 ;padding:5px;">
<div id="prp-ImageProcessing_seperable_kernel_and_rank" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 2</strong></span> 영행렬이 아닌 <span class="math inline">\(m \times n\)</span> 행렬 <span class="math inline">\(\boldsymbol{K}\)</span> 가 <a href="#def-ImageProcessing_seperable_kernel" class="quarto-xref">정의&nbsp;2</a> 와 같이 분리가능한 것과 <span class="math inline">\(\operatorname{rank}(\boldsymbol{K})=1\)</span> 은 동치이다.</p>
</div>
</div>
<p><br></p>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span><span class="math inline">\(\boldsymbol{K}=\boldsymbol{v}\boldsymbol{w}^T\)</span> 이고 <span class="math inline">\(\boldsymbol{v}\)</span>, <span class="math inline">\(\boldsymbol{w}\)</span> 가 모두 열벡터 이므로 두 행렬의 <span class="math inline">\(\operatorname{rank}\)</span> 는 <span class="math inline">\(0\)</span> 혹은 <span class="math inline">\(1\)</span> 이다. 둘 중 하나가 <span class="math inline">\(\operatorname{rank}0\)</span> 이면 <span class="math inline">\(\boldsymbol{K}=\boldsymbol{0}\)</span> 이므로 가정에 모순된다. 따라서 두 열벡터는 모두 <span class="math inline">\(\operatorname{rank}1\)</span> 열벡터 이며 따라서 <span class="math inline">\(\operatorname{rank}(\boldsymbol{K})=1\)</span> 이다.</p>
<p>이제 <span class="math inline">\(\operatorname{rank}(\boldsymbol{K})=1\)</span> 이면 <span class="math inline">\(\boldsymbol{K}\)</span> 에는 <span class="math inline">\(\boldsymbol{0}^T\)</span> 가 아닌 행 <span class="math inline">\(\boldsymbol{k}^T\)</span> 가 존재하며 나머지 행은 <span class="math inline">\(\boldsymbol{k}^T\)</span> 의 (0 을 포함한)스칼라 곱이다. 첫번째 행 <span class="math inline">\(\boldsymbol{k}^T\)</span> 이 <span class="math inline">\(\boldsymbol{0}^T\)</span> 가 아니라고 하자.</p>
<p><span class="math display">\[
\boldsymbol{K} = \begin{bmatrix} \boldsymbol{k}^T \\ a_2 \boldsymbol{k}^T \\ \vdots \\ a_m \boldsymbol{k}^T\end{bmatrix} = \begin{bmatrix} 1 \\ a_2 \\ \vdots \\ a_m \end{bmatrix} \boldsymbol{k}^T
\]</span></p>
<p>이다. 즉 <span class="math inline">\(\operatorname{rank}(\boldsymbol{K})=1\)</span> 이면 <span class="math inline">\(\boldsymbol{K}\)</span> 는 분리가능하다. <span class="math inline">\(\square\)</span></p>
</div>
<p><br></p>
<p>합성곱은 <code>cv.filter2D</code> 함수를 이용한다. <a href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html">OpenCV 관련 페이지</a> 를 참고하라. 뒤에 나올 소벨 커널(<a href="#eq-ImageProcessing_sobel_kernel" class="quarto-xref">식&nbsp;14</a>) 의 <span class="math inline">\(G_x\)</span> 를 적용하면</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>K1 <span class="op">=</span> <span class="fu">arr2mat</span>(<span class="dt">Int32</span>[<span class="fl">1</span> <span class="fl">0</span> <span class="op">-</span><span class="fl">1</span>; <span class="fl">2</span> <span class="fl">0</span> <span class="op">-</span><span class="fl">2</span>; <span class="fl">1</span> <span class="fl">0</span> <span class="op">-</span><span class="fl">1</span>])</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>cv.<span class="fu">filter2D</span>(img0, <span class="op">-</span><span class="fl">1</span>, K1)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div id="fig-ImageProcessing_filter_example" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-ImageProcessing_filter_example-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="notebooks/filter_example.png" class="img-fluid figure-img" width="500">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-ImageProcessing_filter_example-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
그림&nbsp;14: 2D 필터
</figcaption>
</figure>
</div>
<p><code>cv.filter2D</code> 함수의 두번째 인자 <code>-1</code> 은 입력 이미지 <code>img0</code> 와 같은 성분의 타입을 사용하라는 의미이다.</p>
<p><br></p>
</section>
</section>
<section id="빈도-필터" class="level2" data-number="7">
<h2 data-number="7" class="anchored" data-anchor-id="빈도-필터"><span class="header-section-number">7</span> 빈도 필터</h2>
<section id="이미지에-있어-빈도-frequency" class="level3" data-number="7.1">
<h3 data-number="7.1" class="anchored" data-anchor-id="이미지에-있어-빈도-frequency"><span class="header-section-number">7.1</span> 이미지에 있어 ‘빈도 (frequency)’</h3>
<p>이미지의 빈도 혹은 주파수(frequency) 는 매우 많이 등장하는 개념이지만 혼동되기 쉽다. 이미지에서 어떤 픽셀과 바로 이웃한 픽셀의 값이 매우 큰 차이를 보일 때 그 픽셀을 중심으로 픽셀 값의 ’변화’는 매우 크다고 할 수 있다. 이렇게 픽셀 값의 변화가 매우 짧은 픽셀 간격에서 나타날 때, 그 픽셀은 <b>높은 주파수 성분</b>, 반대의 경우를 <b>낮은 주파수 성분</b>이라고 부른다.</p>
<p><br></p>
<section id="하이패스-필터-high-pass-filter-로우패스-필터-low-pass-filter" class="level4">
<h4 class="anchored" data-anchor-id="하이패스-필터-high-pass-filter-로우패스-필터-low-pass-filter"><strong>하이패스 필터 (high-pass filter)</strong>, <strong>로우패스 필터 (low-pass filter)</strong></h4>
<ul>
<li>필터가 낮은 빈도를 나타내는 성분만 제거하거나 픽셀 값을 줄이는 기능을 갖는다면 하이패스(high-pass) 필터라 하고, 그 반대의 경우를 로우패스(low-pass) 필터라 한다.</li>
<li>사실 하이패스 필터는 이미지에서 가장자리 (엣지, edge)를 찾아 내거나 가장자리 신호를 선택적으로 강화하는 기능으로 자주 사용된다.</li>
<li>로우 패스 필터는 반대로 픽셀 값의 변화를 줄이는 역할을 한다. 일반적으로 노이즈 감소 필터는 로우 패스 필터이다. 앞서 살펴 본 평균값 필터, 중간값 필터, 가우시안 필터 등이 로우패스 필터이다. 로우 필터 패스를 사용하면 영상의 차이가 흐려지는 역할을 하기 때문에 블러링(blurring) 이라고 불리기도 한다.</li>
</ul>
<p><br></p>
</section>
</section>
<section id="unsharp-masking-highboost-filtering" class="level3" data-number="7.2">
<h3 data-number="7.2" class="anchored" data-anchor-id="unsharp-masking-highboost-filtering"><span class="header-section-number">7.2</span> Unsharp masking &amp; highboost filtering</h3>
<p><br></p>
<section id="unsharp-mask" class="level4">
<h4 class="anchored" data-anchor-id="unsharp-mask"><strong>Unsharp mask</strong></h4>
<ul>
<li>원본 이미지를 일단 평균값 필터링 같은 로우패스 필터로 블러링 (blurring) 처리한 후, 원본 이미지에서 처리된 이미지를 빼서 차이 값으로 이루어진 행렬을 ‘Unsharp mask’ 라 한다. 원본이미지를 <span class="math inline">\(F[i,j]\)</span>, 블러링 된 이미지를 <span class="math inline">\(\overline{F}[i,j]\)</span> 라 하면 unsharp mask <span class="math inline">\(M[i,j]\)</span> 는 다음과 같다.</li>
</ul>
<p><span id="eq-ImageProcessing_unsharp_mask"><span class="math display">\[
M[i,j]=F[i,j]-\overline{F}[i,j]
\tag{10}\]</span></span></p>
<p><br></p>
</section>
<section id="highboost-filtering" class="level4">
<h4 class="anchored" data-anchor-id="highboost-filtering"><strong>Highboost filtering</strong></h4>
<ul>
<li>이 때 어떤 1보다 큰 양의 실수 <span class="math inline">\(c\)</span> 를 <span class="math inline">\(M[i,j]\)</span> 에 곱해서 원본에 더해준다면 가장자리신호가 더 현저해지며 이것을 highboost filtering 이라 한다. 즉</li>
</ul>
<p><span id="eq-ImageProcessing_highboost_filtering"><span class="math display">\[
G[i,j]=F[i,j]+c\,M[i,j] = F[i,j]+c(F[i,j]-\overline{F}[i,j])
\tag{11}\]</span></span></p>
<p><br></p>
</section>
</section>
<section id="differential-high-pass-filter" class="level3" data-number="7.3">
<h3 data-number="7.3" class="anchored" data-anchor-id="differential-high-pass-filter"><span class="header-section-number">7.3</span> Differential High-pass Filter</h3>
<p>픽셀에 미분, 즉 차분을 적용한다고 하자. 일단 가장 간단하게 생각하면 <span class="math inline">\(x\)</span> 방향 편미분은</p>
<p><span class="math display">\[
\partial_x F [i,j] = F[i,j]-F[i-1,j],\qquad \text{or} \qquad \partial_x F[i,j] = F[i+1,j]-F[i,j]
\]</span></p>
<p>이며 <span class="math inline">\(y\)</span> 방향 편미분은</p>
<p><span class="math display">\[
\partial_y F[i,j] = F[i,j]-F[i,j-1],\qquad \text{or} \qquad \partial_y F[i,j]=F[i,j+1]-F[i,j]
\]</span></p>
<p>가 될 것이다. 이것을 그대로 적용 시킨 커널을 만들 수도 있지만 노이즈에 취약하기 때문에 거의 사용되지 않는다.</p>
<p><br></p>
<section id="로버츠-커널-roberts-kernel" class="level4">
<h4 class="anchored" data-anchor-id="로버츠-커널-roberts-kernel"><strong>로버츠 커널 (Roberts kernel)</strong></h4>
<p>대각선 방향의 편미분에 해당하는 2차원 배열을 로버츠 마스크라 하며 아래와 같다.</p>
<p><span id="eq-ImageProcessing_roberts_kernel"><span class="math display">\[
G_x = \begin{bmatrix} +1&amp;0&amp;0 \\ 0&amp;-1&amp;0 \\ 0&amp;0&amp;0 \end{bmatrix}, \quad G_y=\begin{bmatrix}0&amp;+1&amp;0\\-1&amp;0&amp;0\\0&amp;0&amp;0 \end{bmatrix}
\tag{12}\]</span></span></p>
<p><br></p>
</section>
<section id="prewitt-kernel" class="level4">
<h4 class="anchored" data-anchor-id="prewitt-kernel"><strong>Prewitt kernel</strong></h4>
<p><span id="eq-ImageProcessing_prewitt_kernel"><span class="math display">\[
G_x = \begin{bmatrix}+1&amp;0&amp;-1\\+1&amp;0&amp;-1\\+1&amp;0&amp;-1\end{bmatrix}, \qquad
G_y = \begin{bmatrix}+1&amp;+1&amp;+1\\0&amp;0&amp;0\\-1&amp;-1&amp;-1\end{bmatrix}
\tag{13}\]</span></span></p>
<p><br></p>
</section>
<section id="sobel-kernel" class="level4">
<h4 class="anchored" data-anchor-id="sobel-kernel"><strong>Sobel kernel</strong></h4>
<p><span id="eq-ImageProcessing_sobel_kernel"><span class="math display">\[
G_x = \begin{bmatrix}+1&amp;0&amp;-1\\+2&amp;0&amp;-2\\+1&amp;0&amp;-1\end{bmatrix},\qquad
G_y = \begin{bmatrix}+1&amp;+2&amp;+1\\0&amp;0&amp;0\\-1&amp;-2&amp;-1\end{bmatrix}
\tag{14}\]</span></span></p>
<p><br></p>
</section>
</section>
<section id="laplaician-filter" class="level3" data-number="7.4">
<h3 data-number="7.4" class="anchored" data-anchor-id="laplaician-filter"><span class="header-section-number">7.4</span> Laplaician filter</h3>
<ul>
<li>1차 미분 필터들은 한 번만 차분 값을 계산하기 때문에, 차분의 크기도 작고, 이로 인해서 경계가 확실한 부분만 추출할 수 있는 반면, 노이즈가 있거나 엣지 (edge)의 강도가 약한 부분에는 불완전한 추출을 보이는 한계가 있다.</li>
<li>이를 극복하기 위해 개발된 필터가 2차 미분형, 즉, 라플라시안 필터 (Laplacian filter) 이다. 라플라시안 필터는 말 그대로, 연속 함수 <span class="math inline">\(f(x,y)\)</span>의 이계 도함수를 의미하는 라플라시안으로부터 유래한 것으로, 디지털 이미지에 대해, 아래와 같은 근사 공식을 활용하여 만들 수 있다.</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\nabla^2 f &amp;= \partial_x^2 f + \partial_y^2 f \\
\partial_x^2 I[i,j] &amp; = I[i-1,j]+I[i+1,j]-2I[i,j] \\
\partial_y^2 I[i,j] &amp; = I[i,j-1]+I[i,k+1]-2I[i,j] \\
\nabla^2 I[i,j] &amp;= \partial_x^2 I[i,j]+ \partial_y^2 I[i,j] =I[i-1,j]+I[i+1,j]+I[i,j-1]+I[i,k+1]-4I[i,j]
\end{aligned}
\]</span></p>
<ul>
<li><p>라플라시안 필터는, 앞서 살펴 본 1차 미분형 필터보다, 더 넓은 범위에서 그리고 모든 방향을 고려하여 차분 값을 계산할 수 있기 때문에, 경계선에서 픽셀 값이 변화하는 것 을 훨씬 강한 강도로 잡아낼 수 있으며, 이로 인해, 잡음에도 강하고, 엣지 정보를 더 잘 추출할 수 있다는 장점이 있다. 다만, 계산 시간은 1차 미분형 필터보다는 늘어나게 된다.</p></li>
<li><p>Matlab 에서는 <code>fspecial(‘laplacian’,alpha)</code> 의 명령어로 laplacian kernel 을 만드는데 이는 보통의 laplacian kernel을 약간 수정한 것으로 다음과 같이 정의된다. <span class="math display">\[
\dfrac{1}{1+\alpha} \begin{bmatrix} \alpha &amp; 1-\alpha &amp; \alpha  \\ - \alpha &amp; 4 &amp; - \alpha \\ \alpha &amp; 1-\alpha &amp; \alpha\end{bmatrix}
\]</span></p>
<p>Matlab 에서는 <span class="math inline">\(\alpha\)</span> 값을 <span class="math inline">\([0,\,1)\)</span> 에서 조정한다고 하는데, cv2 에서는 이러한 함수를 찾을 수 없어서 직접 만들어 사용하였다.</p></li>
</ul>
<p><br></p>
</section>
<section id="laplacian-of-gaussian-filter-log-filter" class="level3" data-number="7.5">
<h3 data-number="7.5" class="anchored" data-anchor-id="laplacian-of-gaussian-filter-log-filter"><span class="header-section-number">7.5</span> Laplacian of Gaussian Filter (LoG filter)</h3>
<ul>
<li><p>원본 이미지에 가우시안 블러링을 한 후 라플라시안 필터를 적용한다.</p></li>
<li><p>이 때 LoG filter 는 다음과 같은 꼴을 띈다.</p></li>
</ul>
<p><span class="math display">\[
\nabla^2 \left( G_{\sigma} (x,\,y) \right) = \dfrac{x^2+y^2-2\sigma^2}{\sigma^4} \exp \left(- \dfrac{x^2+y^2}{2\sigma^2}\right)
\]</span></p>
<ul>
<li>라플라시안 필터와 유사하게, LoG 필터도 이미지에서 엣지 부분의 정보를 효과적으로 추출할 수 있다. 특히, 라플라시안 필터보다 더 넓은 범위에서 이미지 합성 곱을 하기 때문에, 이미지 추출 과정에서 왜곡 가능성을 줄일 수 있다는 장점이 있다.</li>
</ul>
<p><br></p>
</section>
<section id="위너-필터-wiener-filter" class="level3" data-number="7.6">
<h3 data-number="7.6" class="anchored" data-anchor-id="위너-필터-wiener-filter"><span class="header-section-number">7.6</span> 위너 필터 (Wiener filter)</h3>
<p>원본 이미지 I 와 노이즈 처리된 이미지 J 사이의 차이를 통계적 관점에서 (혹은 확률적 관점에서) 정량화 하는 방법으로는 평균제곱편차 mean square error (MSE) 가 있다. MSE의 정의는 아래와 같다.</p>
<p><span class="math display">\[
\text{MSE} = \dfrac{1}{N} \sum_{i,\,j} \left[ I[i,\,j]-J[i,\,j]\right]^2
\]</span></p>
<p>위너 필터는 이러한 이미지 간 차이를 최소화하는 모든 종류의 비선형 필터를 의미한다.</p>
<p><br></p>
<section id="위너-필터의-노이즈-감소-기능" class="level4">
<h4 class="anchored" data-anchor-id="위너-필터의-노이즈-감소-기능">위너 필터의 노이즈 감소 기능</h4>
<ul>
<li>원본 이미지 I에 노이즈 N 이 낀 이미지 I’ 를 생각하자. 즉 다음과 같은 식을 생각하자.</li>
</ul>
<p><span class="math display">\[
I'[i,j]=I[i,j]+N[i,j]
\]</span></p>
<ul>
<li>노이즈의 경우 특별한 언급이 없으면 가우시안 노이즈를 생각한다. 그렇다면 노이즈의 평균은 <span class="math inline">\(0\)</span> 이 될 것이며 노이즈의 분산 <span class="math inline">\(\sigma_N^2\)</span> 는 <span class="math inline">\(0\)</span> 이 아닌 값을 갖는다. 어떤 픽셀을 중심으로 커널 배열을 덮어서 움직인다고 하자. 커널은 보통 원본 배열보다 아주 작기때문에 커널에 덮이는 영역의 평균은 <span class="math inline">\(0\)</span> 될 확률이 매우 낮으므로 그 평균값을 <span class="math inline">\(m_{ij}\)</span>, 분산을 <span class="math inline">\(\sigma^2_{ij}\)</span> 라 하자. 이 때 해당 영역의 노이즈를 최소화하는 방식으로 노이즈를 처리하면 다음과 같은 관계식을 얻는다.</li>
</ul>
<p><span class="math display">\[
J[i,j]=m_{ij} + \dfrac{\sigma^2_{ij}}{\sigma^2_{ij} + \sigma^2_N} {\big(} I[i,j]-m_{ij}{\big)}
\]</span></p>
<ul>
<li>그런데 많은 경우 우리는 원본 이미지가 없이 노이즈가 낀 이미지만 있으므로 노이즈의 분산 <span class="math inline">\(\sigma_N^2\)</span> 를 모른다. 여기에 괜찮은 방법이 있는데, 그것은 바로 <span class="math inline">\(\sigma_N^2\)</span> 를 모든 로컬 분산 <span class="math inline">\(\sigma_{ij}^2\)</span> 의 평균으로 잡는 것이다.</li>
</ul>
<p><span class="math display">\[
\sigma_N^2 = \dfrac{1}{N} \sum_{i,j} \sigma^2_{i,j}
\]</span></p>
</section>
<section id="파이썬에서의-위너-필터" class="level4">
<h4 class="anchored" data-anchor-id="파이썬에서의-위너-필터">파이썬에서의 위너 필터</h4>
<p>파이썬에서는 scipy 에서 wiener filter를 사용한다. Library refence 를 보면 대놓고 matlab의 wiener2 함수를 implementation 했다고 나온다. 사용법은 다음과 같다.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.signal.signaltools <span class="im">import</span> wiener</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>filtered_img <span class="op">=</span> wiener(original_img, mysize<span class="op">=</span><span class="dv">3</span>)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>여기서 mysize 는 kernel size 이다. 자세한 것은 library reference 참고. 이 때 주의할 것은 original_img 가 0 에서 255 사이의 정수값을 갖는, 보통 gray scale image 에서 많이 사용되는 uint8 형식의 정수형이면 안된다. 이 경우 다음과 같이 사용하는 것이 좋다.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>filtered_img <span class="op">=</span> wiener(original_img.astype(np.float64), ksize)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "복사완료!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "복사완료!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/julia-kaeri\.github\.io\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../../src/image_processing/index.html" class="pagination-link" aria-label="영상 처리">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">영상 처리</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../../src/image_processing/image_processing_02.html" class="pagination-link" aria-label="푸리에 변환을 이용한 이미지 처리">
        <span class="nav-page-text">푸리에 변환을 이용한 이미지 처리</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>