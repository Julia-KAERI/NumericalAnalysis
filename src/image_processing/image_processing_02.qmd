---
title: "공간적 이미지 필터링"

number-sections: true
number-depth : 3
crossref:
  chapters: false
---

{{< include ../../latexmacros.qmd >}}

</br>

## 커널과 필터
- **커널** : 이미지의 처리를 위해 특정한 기능을 수행하는 2차원 배열. 마스크 라고도 한다. 
- **필터** : 커널+기능의 조합을 필터 (filter)라 한다.


</br>

### 공간적 필터링 (Spatial filtering)

공간적 필터링이라 함은 동일한 공 간에 어떤 필터 행렬을 생성시켜서, 그 필터 행렬과 원본 이미지 행렬 사이의 연산을 수 행하는 것

</br>

## 선형 필터 (linear filter)

- 필터링 연산이 선형성을 갖는 경우를 이 필터에 의한 연산을 선형 필터라 한다. 

$\ast$ 이후 원본 이미지 $I$ 에 대해 필터링된 이미지를 $J$ 라 하자. $I$ 의 $(i,\,j)$ 위치의 필셀값을 $I[i,\,j]$ 라 하자. 

<br>

### 평균값 필터 (Averaging filter)
이미지의 어떤 픽셀과 그 주변의 선택된 픽셀값과의 평균으로 필셀값을 대체하는 필터. 당연히 커널은 아래와 같은 모양을 띈다.

$$
\frac{1}{9}\begin{bmatrix} 1 & 1 & 1 \\ 1 & 1 & 1 \\1 & 1 & 1 \end{bmatrix}
$$
이 때 픽셀의 값은 자신을 중심으로 한 $3\times 3$ 배열의 평균으로 대체된다. 즉

$$
J[i,\,j]=\frac{1}{9} \sum_{p=-1,\,0,\,1} \sum_{q=-1,\,0,\,1} I[i-p,\,j-q]
$$

이다. 

python에서는 cv2 라이브러리를 사용하여 다음과 같이 이용한다

```python
import cv2
kernel = np.ones((5,5),np.float32)/25
filtered_image = cv2.filter2D(original_image, -1, kernel)
```

kernel 은 $5 \times 5$ 행렬을 사용하였다. `cv2.filter2D` 함수에서의 -1 은 일단 original image 와 같은 자료형으로 filtered image 가 생성된다고 알아 두자. 

<br>

#### 가장자리 처리
이 경우 가장자리면, 즉 $i=0$ 이면 $i-1$ 픽셀이 없으므로 문제가 된다. 이렇게 필터를 쓸 경우 경계값이 문제가 되는데 이에 대한 방법은 원본 이미지를 커널을 고려하여 사이즈를 키운 다음에 새로 키워진 행렬을 특정한 값으로 채우는 것이다. $0$ 으로 채울수도 있고 가까운 경계값으로 채울 수도 있으며 다른 여려 방법이 존재한다. 각각의 경우에 맞춰 적절하게 사용할 수 밖에 없다.

<br>

### 가우시안 필터 (Gaussian filter)
$I[i,j]$ 를 필터링 할 때 주변 값과 정규분포 관계가 있다고 가정한다. 즉 멀수록 관계가 더 적다고 간주한다. 2차원 가우시안 함수는 다음과 같다.

$$
G(x,\,y | x',\,y') = \dfrac{1}{\sqrt{2 \pi \sigma^2}} \exp \left( -\dfrac{(x-x')^2+(y-y')^2}{2\sigma^2}\right)
$$

$J[i,\,j]$ 는 $I[i,\,j]$ 를 중심으로 주변값에 2차원 가우시안 함수에 비례하는 가중치를 두고 그 평균을 계산한 값이 된다. 

python의 cv2 라이브러리에서는 다음과 같이 사용한다.

```python
filtered_image = cv2.GaussianBlur(original_image, (3, 3), 1.5)
```

여기서 `(3, 3)` 은 $3 \times 3$ 크기의 커널을 사용한다는 뜻이고 1.5 는 가우시안 분포의 표준편차이다.

</br>

## 비선형 필터 (nonlinear filter)

### 비선형 필터
- 중앙값 필터 (median filter) : 노이즈 처리에 좋다.

- 표준편차 필터(standard deviation filter) : 엣지 검출에 좋다.

</br>

## 합성곱 개념으로서의 이미지 필터링

### 합성곱과 상관값
원본 이미지 $I[i,\,j]$ 와 kernel $k[i,\,j]$ 사이의 합성곱 $g=k \ast I$ 와 상관값 $c=k \otimes I$ 는 각각 다음과 같이 정의된다.

$$
\begin{aligned}
g[i,\,j] &= k \ast I = \sum_{s=-a}^{a} \sum_{t=-b}^b k[s,\,t] \,I[i-s,\, j-t]\\
c[i,\,j] &= k \otimes I = \sum_{s=-a}^{a} \sum_{t=-b}^b k[s,\,t]\, I[i+s,\, j+t]
\end{aligned}
$$

</br>

## 빈도 필터

### 이미지에 있어 ‘빈도 (frequency)’
- 이미지에서 어떤 픽셀과 바로 이웃한 픽셀의 값이 매우 큰 차이를 보일 때 그 픽셀을 중심으로 픽셀 값의 ‘변화’는 매우 크다고 할 수 있다. 이렇게 픽셀 값의 변화가 매우 짧은 픽셀 간격에서 나타날 때, 그 픽셀은 <b>높은 주파수 성분</b>, 반대의 경우를 <b>낮은 주파수 성분</b>이라고 부른다.

<br>

#### 하이패스 필터 (high-pass filter), 로우패스 필터 (low-pass filter)
- 필터가 낮은 빈도를 나타내는 성분만 제거하거나 픽셀 값을 줄이는 기능을 갖는다면 하이패스 필터라 하고, 그 반대의 경우를 로우패스 필터라 한다.
- 사실 하이패스 필터는 이미지에서 가장자리 (엣지, edge)를 찾아 내거나 가장자리 신호를 선택적으로 강화하는 기능으로 자주 사용된다. 
- 앞서 살펴 본 평균값, 중간값, 가우시안 필터 등이 로우패스 필터이다. 

</br>

### Unsharp masking & highboost filtering

<br>

#### **Unsharp mask**
- 원본 이미지를 일단 평균값 필터링 같은 로우패스 필터로 블러링 (blurring) 처리한 후, 원본 이미지에서 처리된 이미지를 빼서 차이 값으로 이루어진 행렬을 ‘Unsharp mask’ 라 한다. 원본이미지를 $I[i,j]$, 블러링 된 이미지를 $\overline{I}[i,j]$ 라 하면 unsharp mask $M[i,j]$ 는 다음과 같다.

$$
M[i,j]=I[i,j]-\overline{I}[i,j]
$$

<br>

#### **Highboost filtering**
- 이 때 어떤 1보다 큰 양의 실수 $k$ 를 $M[i,j]$ 에 곱해서 원본에 더해준다면 가장자리신호가 더 현저해지며 이것을 highboost filtering 이라 한다. 즉

$$
J[i,j]=I[i,j]+k\,M[i,j] = I[i,j]+k(I[i,j]-\overline{I}[i,j])
$$

</br>

### Differential High-pass Filter

픽셀에 미분을 적용한다면 일단 간단하게 생각하면, $x$ 방향 편미분은 $\partial_x I [i,j]=I[i,j]-I[i-1,j]$ or $\partial_x I[i,j]=I[i+1,j]-I[i,j]$ 이며 $y$ 방향 편미분은 $\partial_y I[i,j]=I[i,j]-I[i,j-1]$ 혹은 $\partial_y I[i,j]=I[i,j+1]-I[i,j]$ 가 될 것이다. 

<br>

#### **로버츠 커널 (Roberts kernel)**

대각선 방향의 편미분에 해당하는 2차원 배열을 로버츠 마스크라 하며 아래와 같다.

$$
G_x = \begin{bmatrix} +1&0&0 \\ 0&-1&0 \\ 0&0&0 \end{bmatrix}, \quad G_y=\begin{bmatrix}0&+1&0\\-1&0&0\\0&0&0 \end{bmatrix}
$$

<br>

#### **Prewitt kernel**

$$
G_x = \begin{bmatrix}+1&0&-1\\+1&0&-1\\+1&0&-1\end{bmatrix}, \qquad 
G_y = \begin{bmatrix}+1&+1&+1\\0&0&0\\-1&-1&-1\end{bmatrix}
$$

<br>

#### **Sobel kernel**

$$
G_x = \begin{bmatrix}+1&0&-1\\+2&0&-2\\+1&0&-1\end{bmatrix},\qquad
G_y = \begin{bmatrix}+1&+2&+1\\0&0&0\\-1&-2&-1\end{bmatrix}
$$


</br>

### Laplaician filter

- 1차 미분 필터들은 한 번만 차분 값을 계산하기 때문에, 차 분의 크기도 작고, 이로 인해서 경계가 확실한 부분만 추출할 수 있는 반면, 노이즈가 있거나 엣지 (edge)의 강도가 약한 부분에는 불완전한 추출을 보이는 한계가 있다. 
- 이를 극복하기 위해 개발된 필터가 2차 미분형, 즉, 라플라시안 필터 (Laplacian filter) 이다. 라플라시안 필터는 말 그대로, 연속 함수 f(x,y)의 이계 도함수를 의미하는 라플라시안으로부터 유래한 것으로, 디지털 이미지에 대해, 아래와 같은 근사 공식을 활용하여 만들 수 있다.

$$
\begin{aligned}
\nabla^2 f &= \partial_x^2 f + \partial_y^2 f \\ 
\partial_x^2 I[i,j] & = I[i-1,j]+I[i+1,j]-2I[i,j] \\
\partial_y^2 I[i,j] & = I[i,j-1]+I[i,k+1]-2I[i,j] \\
\nabla^2 I[i,j] &= \partial_x^2 I[i,j]+ \partial_y^2 I[i,j] =I[i-1,j]+I[i+1,j]+I[i,j-1]+I[i,k+1]-4I[i,j]
\end{aligned}
$$


- 라플라시안 필터는, 앞서 살펴 본 1차 미분형 필터보다, 더 넓은 범위에서 그리고 모든 방향을 고려하여 차분 값을 계산할 수 있기 때문에, 경계선에서 픽셀 값이 변화하는 것 을 훨씬 강한 강도로 잡아낼 수 있으며, 이로 인해, 잡음에도 강하고, 엣지 정보를 더 잘 추출할 수 있다는 장점이 있다. 다만, 계산 시간은 1차 미분형 필터보다는 늘어나게 된다.


- Matlab 에서는 `fspecial(‘laplacian’,alpha)` 의 명령어로 laplacian kernel 을 만드는데 이는 보통의 laplacian kernel을 약간 수정한 것으로 다음과 같이 정의된다.
  $$
  \dfrac{1}{1+\alpha} \begin{bmatrix} \alpha & 1-\alpha & \alpha  \\ - \alpha & 4 & - \alpha \\ \alpha & 1-\alpha & \alpha\end{bmatrix}
  $$

  Matlab 에서는 $\alpha$ 값을 $[0,\,1)$ 에서 조정한다고 하는데, cv2 에서는 이러한 함수를 찾을 수 없어서 직접 만들어 사용하였다. 

</br>

### Laplacian of Gaussian Filter (LoG filter)

- 원본 이미지에 가우시안 블러링을 한 후 라플라시안 필터를 적용한다.

- 이 때 LoG filter 는 다음과 같은 꼴을 띈다.

$$
\nabla^2 \left( G_{\sigma} (x,\,y) \right) = \dfrac{x^2+y^2-2\sigma^2}{\sigma^4} \exp \left(- \dfrac{x^2+y^2}{2\sigma^2}\right)
$$

- 라플라시안 필터와 유사하게, LoG 필터도 이미지에서 엣지 부분의 정보를 효과적으로 추출할 수 있다. 특히, 라플라시안 필터보다 더 넓은 범위에서 이미지 합성 곱을 하기 때문에, 이미지 추출 과정에서 왜곡 가능성을 줄일 수 있다는 장점이 있다.

</br>

### 위너 필터 (Wiener filter)

원본 이미지 I 와 노이즈 처리된 이미지 J 사이의 차이를 통계적 관점에서 (혹은 확률적 관점에서) 정량화 하는 방법으로는 평균제곱편차 mean square error (MSE) 가 있다. MSE의 정의는 아래와 같다.

$$
\text{MSE} = \dfrac{1}{N} \sum_{i,\,j} \left[ I[i,\,j]-J[i,\,j]\right]^2
$$

위너 필터는 이러한 이미지 간 차이를 최소화하는 모든 종류의 비선형 필터를 의미한다. 

<br>

#### 위너 필터의 노이즈 감소 기능

- 원본 이미지 I에 노이즈 N 이 낀 이미지 I' 를 생각하자. 즉 다음과 같은 식을 생각하자.

$$
I'[i,j]=I[i,j]+N[i,j]
$$

- 노이즈의 경우 특별한 언급이 없으면 가우시안 노이즈를 생각한다. 그렇다면 노이즈의 평균은 $0$ 이 될 것이며 노이즈의 분산 $\sigma_N^2$ 는 $0$ 이 아닌 값을 갖는다. 어떤 픽셀을 중심으로 커널 배열을 덮어서 움직인다고 하자. 커널은 보통 원본 배열보다 아주 작기때문에 커널에 덮이는 영역의 평균은 $0$ 될 확률이 매우 낮으므로 그 평균값을 $m_{ij}$, 분산을 $\sigma^2_{ij}$ 라 하자. 이 때 해당 영역의 노이즈를 최소화하는 방식으로 노이즈를 처리하면 다음과 같은 관계식을 얻는다.

$$
J[i,j]=m_{ij} + \dfrac{\sigma^2_{ij}}{\sigma^2_{ij} + \sigma^2_N} {\big(} I[i,j]-m_{ij}{\big)}
$$

- 그런데 많은 경우 우리는 원본 이미지가 없이 노이즈가 낀 이미지만 있으므로 노이즈의 분산 $\sigma_N^2$ 를 모른다. 여기에 괜찮은 방법이 있는데, 그것은 바로 $\sigma_N^2$ 를 모든 로컬 분산 $\sigma_{ij}^2$ 의 평균으로 잡는 것이다. 

$$
\sigma_N^2 = \dfrac{1}{N} \sum_{i,j} \sigma^2_{i,j}
$$


#### 파이썬에서의 위너 필터

파이썬에서는 scipy 에서 wiener filter를 사용한다. Library refence 를 보면 대놓고 matlab의 wiener2 함수를 implementation 했다고 나온다. 사용법은 다음과 같다.

~~~python
from scipy.signal.signaltools import wiener

filtered_img = wiener(original_img, mysize=3)
~~~

여기서 mysize 는 kernel size 이다. 자세한 것은 library reference 참고. 이 때 주의할 것은 original_img 가 0 에서 255 사이의 정수값을 갖는, 보통 gray scale image 에서 많이 사용되는 uint8 형식의 정수형이면 안된다. 이 경우 다음과 같이 사용하는 것이 좋다.

~~~python
filtered_img = wiener(original_img.astype(np.float64), ksize)
~~~
