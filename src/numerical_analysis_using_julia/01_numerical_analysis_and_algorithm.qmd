---
title: "수치해석 (Numerical Analysis) 과 알고리즘 (Algorithm)"

number-sections: true
number-depth: 2
crossref:
  chapters: false
---

현대의 수치 해석은 어떤 수학적인 문제를 컴퓨터를 이용하여 계산하는 것이다. $4x+2=6$ 과 같은 단순한 방정식의 해를 구하는 것 부터 아주 큰 행렬을 이용한 계산이나 복잡한 미분방정식을 푸는 것까지 사용되고 있다. 수치 해석이 필요한 이유는 복잡하거나, 계산의 양이 많거나, 정확한 해를 구하기가 힘들어 근사적으로 구해야 하는 등 사람이 직접 수행하기 힘든 난관이 존재하기 때문이다.

우리는 5차 이상의 방정식이 해석적으로 풀리지 않는다는 것을 알고 있다. 방정식이 해석적으로 풀린다는 것은 $ax^2+bx+c=0$ 의 해가 $\dfrac{-b \pm \sqrt{b^2-4ac}}{2}$ 인 것처럼 방정식의 계수들로 이루어진 식으로 존재하지 않는 다는 것이다. 자연과학과 공학에서 매우 중요한 미분방정식의 경우는 해석적인 해가 존재하는 경우가 오히려 드물다. 점성을 가진 유체의 흐름을 기술하는 나비에-스토크스 방정식 (Navier-Stokes equation) 의 경우는 그 3차원에서 그 해가 존재하는지 여부가 소위 밀레니엄 문제로 지정되었으며 아직 풀리지 않았고, 현재에도 나비에-스토크스 방정식은 아주 제한된 경우에 근사적으로 수치해석을 이용하여 계산할 뿐이다.

</br>

## 컴퓨터에서의 정수와 실수(Real number) 의 표현

현대의 컴퓨터는 2진수로 모든것을 표현한다. 하나의 2진 단위를 비트 (bit) 라 하며 보통 8개의 비트 하나로 묶은 단위를 바이트 (Byte) 라 한다. 우리가 다루는 컴퓨터는 정해진 수의 바이트 수에 특정한 규칙에 따라 수를 표현한다. 예를 들어 8비트, 즉 1바이트에 정수를 표현한다고 하자. 이것으로 표현 할 수 있는 정수는 2<sup>8</sup>=256 개가 전부이다. 이것보다 더 많은 정수를 표현하기 위해서는 더 큰 비트수를 차지하는 정수형을 사용해야 한다. Julia 에서 실수 표현의 기본값으로 많이 쓰이는 64비트 부동 소수(floating number)의 경우에는 표현할 수 있는 실수의 갯수는 최대 2<sup>64</sup> ($\approx$ 1.8×10<sup>19</sup>) 이며 실제로는 이것보다 다소 작다. 아주 큰 수 이기는 하지만 무한은 아니다. 

</br>

### 정수의 표현

[Introductio to Julia](https://julia-kaeri.github.io/IntroductionToJulia/) 의 [기본적인 수 타입](https://julia-kaeri.github.io/IntroductionToJulia/src/introduction_to_julia/02_variables_basic_types.html#sec-primary_number_types) 과 [정수형 타입](https://julia-kaeri.github.io/IntroductionToJulia/src/introduction_to_julia/02_variables_basic_types.html#sec-integer_types) 을 참고하라.

</br>

많은 언어들이 정수에 대해 1, 2, 4, 8, 16 바이트 정수형을 제공한다. 예를 들어 8바이트, 즉 64비트 정수형의 경우는 2<sup>64</sup>=18_446_744_073_709_551_616 개 즉, 대략 $1.8 \times 10^{19}$ 개의 정수를 표현 할 수 있다. 정수는 각 바이트에 대해 부호 있는 정수와 부호 없는 정수의 자료형이 있다. 예를 들어 2바이트 부호 없는 정수의 경우 $0$ 부터 $2^16=65536$ 까지의 정수를 다룰 수 있다. Julia 의 경우 2바이트 부호 없는 정수를 위한 자료형은 `UInt16` 이다. 부호 있는 정수의 경우에는 전체 바이트중 하나를 부호 즉 음수와 앙수를 구별하는데 사용한다. 기본적으로 부호 있는 정수에서 모든 비트가 $0$ 이면 정수 $0$ 으로 간주한다. 2바이트 부호 있는 정수의 경우 $-32758$ 에서  $+32757$ 까지의 정수를 다룰 수 있다.


</br>

### 실수(Real Number) 의 표현

빛의 속도 $c$ 는 299792458 m/s = 0.299792458 x 10<sup>9</sup> m/s 이다. 여기서 0.299794568 부분을 가수(mentissa) 라고 하고 10<sup>9</sup> 를 지수(exponent)라 한다. 실수를 이렇게 가수와 지수로 나누어 표현하는 것을 부동소수점 표현이라고 하며 실수(real number)를 컴퓨터에서 표현 할 때 부동소숫점 표현(floating point representation) 이 기본적으로 사용된다. 이에 대비되는 것이 고정 소숫점 표현(fixed point representation) 이다.


### 고정소숫점 표현

기본적인 원리는 정해진 데이터 비트에서 정수부분과 소수부분의 비트가 나누어져 있다. 예를 들자면 16비트 고정소수표현에서 맨 앞의 한 비트는 음수와 양수를 구분하는데, 그 다음의 9비트는 정수부에, 마지막 6비트는 소수부를 다루는데 사용 할 수 있다. 고정소숫점 표현은 정수의 연산을 거의 그대로 사용 할 수 있기 때문에 아래의 부동소숫점 표현보다 빠르게 계산 할 수 있다. 그러나 표현 할 수 있는 숫자의 범위가 매우 제한되어 있어 아래의 부동소숫점 표현보다는 사용도가 훨씬 적다. 

Julia 의 대표적인 이미지 처리 패키지인 [Images.jl](https://github.com/JuliaImages/Images.jl) 에서는 픽셀의 색상 정보에 고정소숫점 표현을 사용한다. 


### 부동소숫점표현

Julia 는 부동소숫점 표현에서 The IEEE 754 기준을 따른다.[실제로는 대부분의 컴퓨팅 연산의 기본이 `IEEE 754` 이다]{.aside} 이 기준에 따르면, 64비트 실수 (이후 `Float64` 라 한다)의 경우 음수/양수 를 나타내는 1 비트, 지수를 나타내는 `UInt` 형식의 11비트, 가수를 나타내는 52비트로 이루어진다. 각각의 비트를 $b_0,\,b_1,\ldots,\,b_{63}$ 이라 하자. $0$ 부터 시작하는 인덱스에 익숙하지 않은 독자를 위해 설명하자면 C, C++, Python 등 많은 언어는 배열의 인덱스를 $0$ 부터 시작하도록 한다. Fortran 이나 Julia 는 $1$ 시작하지만, 메모리 비트를 표현할때는 보통 $0$ 부터 시작하는계 관례이므로 여기서는 $0$ 부터 시작하도록 하자. 64 비트 실수형이므로 인덱스는 $0$ 부터 $63$ 까지 이다.

이 때 마지막 비트, 즉 $b_{63}$ 을 최상위 비트라 하고, 양수인지, 음수인지를 나타내는 비트이다. 이 값을 $p$ 라 하자. $0$ 이면 양수, $1$ 이면 음수이다. $b_{52}$ 부터 $b_{62}$ 까지는 지수 정보를 저장한다. 지수정보는 `UInt` 형식으로 저장되며 지수를 $e$ 라 하면,

$$
e= \sum_{i=0}^{10} b_{52+i} 2^i
$$

이다. $e$ 는 $0$ 부터 $2047$ 까지의 값을 가질 수 있지만 실제 지수로서 기능하는 것은 $1$ 부터 $2046$ 까지이다. $e=0$ 일 때와, $e=2047$ 일 때는 뒤에 기술하는 특별한 방법을 사용한다($e=2047$ 에 대해서는 @sec-floating_number_NAN 을 보라.) .

가수는 $b_{0}$ 부터 $b_{51}$ 까지의 비트에 저장된다. 가수 $m$ 이 의미하는 값은 $e$ 값에 따라 아래와 같이 결정된다.

$$
m= \left\{ \begin{array}{ll} 1.0+ \displaystyle{\sum_{i=1}^{52}} \, b_{52-i}2^{-i} \qquad & \text{if }e>0\,,\\ \displaystyle{\sum_{i=1}^{52}}\, b_{52-i}2^{-i} & \text{if }e = 0\,. \end{array} \right.
$$

가수 $m$의 범위는  $e>0$ 일 때는 $1\le m < 2$ 이고 $e=0$ 일 때는 $0\le m < 1$ 이다. $e>0$ 일 경우, 52 비트로 1.0 이하의 유효숫자를 표현하고 거기에 에 1을 더해주기때문에 실제적으로는 가수는 53 bit 로 저장된다고 볼 수 있다.  $e=0$ 일 경우는 52비트로 저장된다고 볼 수 있다. $2^{-53}  \approx 1.1 \times 10^{-16},\, 2^{-52} \approx 2.2 \times 10^{-16}$ 이므로 `Float64` 형식의 실수는 소수점 아래 17자리 이하의 가수의 차이는 구별 할 수 없다. 즉 $1.0 + 1.0 \times 10^{-17}$ 은 $1.0$ 과 구별되지 않는다.

이제 부호 $p$ 와 지수 $e$, 가수 $m$ 을 이용해 실수 $r$ 을 표현하면,

$$
r=\left\{ \begin{array}{ll} (-1)^p \times m \times 2^{e-1023}  \qquad & \text{if }e>0\,, \\ (-1)^p \times m \times e^{-1022} & \text{if } e=0 \,.\end{array}\right.
$$

이다.

한가지 언급하자면, $e=0,\,m=0.0$ 일 경우 $p$ 값에 관계 없이 $0.0$ 이 된다. 즉, 실수 $0.0$ 을 `Float64`로 표현하는 방법은 2가지로 $+0.0$ 과 $-0.0$ 인데, 대부분의 언어는 특별한 경우를 제외하면 이 둘을 동일하게 처리하도록 되어 있다.

</br>

#### NaN, $\pm \infty$ {#sec-floating_number_NAN}

앞서 지수 $e$ 가 2047일 경우는 특별히 다룬다고 언급하였다.

IEEE 754 표준에서는 `NaN` 과 양/음의 무한대 표현을 정의한다. 지수비트가 모두 $1$ 이고 가수비트가 모두 $0$ 이면 무한대를 의미한다. 부호비트가 $0$ 이면 $+\infty$, 부호비트가 $1$ 이면 $-\infty$ 이다.

$e=2047$ 이고 양과 음의 무한대를 표현하는 경우를 제외하면 모두 `NaN` 으로 처리한다. `NaN` 은 *Not a Number* 의 약자로, 연산 과정 등에서의 오류를 표현한다. `NaN` 도 종류에 따라 구분하는 경우가 있지만 여기서는 다루지 않는다.

아래 표는 이런 특별한 표현을 정리한 것이다.

| $b_{63}$ | $b_{62}$ ~ $b_{52}$ | $b_{51}$ ~ $b_{0}$| 표현 |
| :----: | :----: | :----: | :----: |
| `0` | `00000000000` | `0000000000000000000000000000000000000000000000000000` |+0.0 |
| `1` | `00000000000` | `0000000000000000000000000000000000000000000000000000` | −0.0 |
| `0` | `11111111111` | `0000000000000000000000000000000000000000000000000000` | $+\infty$ |
| `1` | `11111111111` | `0000000000000000000000000000000000000000000000000000` | $-\infty$ |
| `0` | `11111111111` | `0000000000000000000000000000000000000000000000000001` | NaN |
| `0` | `11111111111` | `1000000000000000000000000000000000000000000000000001` | NaN |
| `0` | `11111111111` | `1111111111111111111111111111111111111111111111111111` | NaN |

</br>

혹시나 관심있는 사람을 위해 `bitstring` 함수를 소개한다. 이 함수는 값을 비트표현의 문자열로 바꾸어준다.

```julia
In [9]: bitstring(0.0)
Out[9]: "0000000000000000000000000000000000000000000000000000000000000000"

In [10]: bitstring(Inf)
Out[10]: "0111111111110000000000000000000000000000000000000000000000000000"

In [11]: bitstring(-Inf)
Out[11]: "1111111111110000000000000000000000000000000000000000000000000000"

In [12]: bitstring(UInt8(255))
Out[12]: "11111111"

In [13]: bitstring(UInt8(1))
Out[13]: "00000001"
```

</br>


## Trunctation error, Round-off error

컴퓨터로 수치해석을 하는 경우 오류가 있을 수 있다. 프로그래밍적으로 오류가 발생하여 실행되지 않을 수도 있고, 프로그래머의 오류로 (예를 들면 더해야 하는데 곱한다던가) 틀린 답을 낼 수도 있다. 이런 인적 오류 이외에 발생할 수 있는 오류로는 컴퓨터를 이용한 계산이기 때문에 어쩔수 없이 발생가게 되는 에러-truncation error 와 round-off error 가 있다.

</br>

### Truncation error

Truncation error 는 수학적 근사에서 기인하는 오차이다. 예를 들어 $e^x$ 를 테일러 전개를 이용하여 계산한다면,

$$
e^x \approx 1+x+\dfrac{x^2}{2} + \dfrac{x^3}{3!} + \cdots + \dfrac{x^n}{n!}+ \cdots
$$

임을 이용한다. 그런데 컴퓨터는 무한번 계산을 할 수 없으므로 어느 정도에 끊어야 하며, 나머지 항에 의한 값이 오차가 될 것이다. 이러한 오차를 truncation error 라 한다. 혹은 앞으로 많이 사용하겠지만 어떤 함수나 수열의 미분을 계산함에 있어

$$
f'(x_0) \approx \dfrac{f(x_0 + h)-f(x_0)}{h}
$$

와 같은 근사(approximation)를 사용하는데 어떤 특정한 작은 $h$ 값을 사용하게 됨으로서 발생하는 오차도 truncation error 라고 할 수 있다.

</br>

### Round-off Error

Round-off error 는 앞서 알아본 실수의 컴퓨터 표현에 의한 오차이다. 실수의 갯수는 무한대이며, 임의의 서로 다른 두 실수 사이에도 무한개의 실수가 존재한다. 그러나 64비트로 표현 가능한 실수는 최대한 $2^{64} \approx 1.8\times 10^{19}$ 정도이다. 또한 앞서 알아봤듯이 유효숫자의 갯수는 10진수 표현으로 대략 16개 이며, IEEE 754 표준을 따르면 $3.6$ 과 $3.6+1.0 \times 10^{-16}$ 은 구별되지 않는다. Julia 언어로 다음과 같이 계산해보자.

```julia
In [1]: 3.6-2.4-1.2
Out[1]: 2.220446049250313e-16

In [2]: 3.6-1.2-2.4
Out[2]: 4.440892098500626e-16
```

다음과 같은 결과를 얻는다. 우리는 $3.6-2.4-1.2=0.0$ 임을 알고 있지만, 컴퓨터로 계산한 결과는 다르다. 게다가 $3.6-2.4-1.2$ 와 $3.6-1.2-2.4$ 의 결과가 다르다. 이것은 불가피하며, 인간적인 관점에서는 다소 무작위적이기 때문에 계산을 하는 사람이 항상 주의해야 할 수 밖에 없다.

또하나의 예를 들면,

```julia
In [3]: (3.4/1.6)*1.6
Out[3]: 3.4000000000000004
```

이다. 우리는 이 값이 `3.4` 이어야 함을 알고 있지만 ronnd-off 에러에 의해 결과가 $3.4+4.0\times 10^{-16}$ 으로 나왔다. 이는 `Float64` 에서 다루는 유효숫자의 갯수가 10진법으로 대략 16개 정도이기 때문에 발생한다.

</br>



## 계산의 분석

특정 프로그래밍 언어를 사용하여 작성된 알고리즘이 어떤 정해진 문제를 해결하는 데 걸리는 시간을 예측하는 것은 거의 불가능하며, 보통 알고리즘을 실행 속도 측면에서 분석할 때는 수행 시간이 문제의 크기를 표현하는 변수 $n$ 에 대해 점근적으로 어떻게 행동하는지 예측한다. 여기서 $n$ 은 벡터의 차원, 행렬의 크기, 다항식의 차수(degree) 등을 의미한다. 보통 $n$ 이 커짐에 따라 수행시간이 어떻게 되는지에 관심이 있기 때문에 $n\to \infty$ 극한에서 생각하는데, 알고리즘의 계산 복잡도 (computational complexity) 를 분석하는 방법으로 많이 사용되는 것 중 하나가 대문자 $O$ 표기법이다.

</br>

### FLOP {#sec-flop}

수행 시간을 계산할 때 대상의 크기에 대한 변수 $n$ 에 대해 몇번의 기본연산을 수행하는지를 따진다. 많이 사용되는 FLOP(floating-point operations) 는 계산에 수행되는 모든 스칼라 사칙연산과 제곱근 계산을 1 flop 단위로 삼아 $n$ 에 대한 함수 $T(n)$ 으로 표현한다. 예를 들어 $n$ 차원 공간에서의 두 벡터 `u`, `v` 의 내적은

```julia
udotv = 0.0
for i = 1:n
    udotv = udotv + u[i] * v[i]
end
```

를 통해 계산 할 수 있으며, $n$ 번의 스칼라곱과 $n-1$ 번의 스칼라합 계산이 수행되므로 내적에 대해서는 $T(n) = 2n-1$ 이다. $n \times n$ 두 행렬 `A`, `B` 의 곱 `C` 는

```julia
for i = 1:n
    for j = 1:n
        for k = 1:n
            C[i, j] = C[i, j] + (A[i, k] * B[k, j])
        end
    end
end
```

로 계산 할 수 있으며, $n^3$ 번의 스칼라곱과 $n^3$ 번의 스칼라 합 계산이 수행되므로 $T(n) = 2n^3$ 이다. 

</br>

### 대문자 $O$ 표기법 {#sec-big_O_notation}

예를 들어 $T(n) =  n^3+n$ 이라고 하자. $n$ 이 매우 클 경우 $T(n)$ 의 값에 대한 기여는 대부분 $n^3$ 에서 오며 $n$ 이 기여하는 바는 미미하다. 이 때 함수를 가장 크게 기여하는 부분만을 표현하는 방법이 대문자 $O$ 표기법이다. 


#### 대문자 $O$ 표기법의 정의

자연수 $n$ 에 대한 양의 함수 $f(n)$, $g(n)$ 에 대해 $f(n) = O(g(n))$ 은

$$
\lim_{n \to \infty}\dfrac{f(n)}{g(n)} <\infty
$$

이 됨을 의미한다. 또한 $f(n) \sim O(g(n))$ 은

$$
\lim_{n \to \infty}\dfrac{f(n)}{g(n)} =1
$$

을 의미한다.

</br>

보통 $O(f(n))$ 에서 $f(n)$ 은 가능한 함수 가운데 가장 간단한 함수를 사용한다. 예를 들어,

$$
\begin{aligned}
2n^3-3n+1 &= O(n^2)\\
n \ln(n) + 3n &= O(n \ln (n))
\end{aligned}
$$

과 같다. 
즉, $2n-1 = O(n)$ 이다. $n \times n$ 행렬 $\boldsymbol{A},\,\boldsymbol{B}$ 의 곱 $\boldsymbol{C}=\boldsymbol{AB}$ 를 생각하자. $C_{ij} = \boldsymbol{A}_{i:}\cdot \boldsymbol{B}_{:j}$ 이므로 $T(n) = 2n^3-n^2 = O(n^3)$ 이다.

</br>


## 알고리즘과 루프 불변성

알고리즘은 어떤 문제가 주어졌을 때 이 문제를 풀기 위한 구체적인 방법으로 유한번의 절차 이후 종료되어야 한다. 수치해석에서 대부분의 중요한 알고리즘은 `for ... end` 나 `while ... end` 같은 루프문 과 `if ... elseif ... else... end` 같은 분기문으로 이루어져 있다. 루프로 이루어지는 알고리즘이 가져야 할 가장 중요한 성질이 **루프 불변성 (loop invariance)** 이다. 알고리즘상의 어떤 명제 혹은 식 $P$가 아래와 같은 성질을 만족하면 루프 불변이라고 한다.

- 초기조건 : 루프가 첫 번째 반복을 시작하기 전에 $P$가 참이어야 한다

- 유지조건 : 루프의 $N$ 회차 반복이 시작되기 전에 $P$ 가 참이었다면 $N+1$ 회차 반복이 시작되기 전까지도 계속 참이어야 한다

- 종료조건 : 루프가 종료될 때 $P$이 알고리즘의 타당성을 보이는 데 도움이 될 유용한 특성을 가져야 한다

초기조건과 유지조건은 수학적 귀납법이 성립하는 조건과 동일하다는 것을 쉽게 알 수 있을 것이다. 세번째 종료조건이 여기에 고유한 것으로 어쨌든 알고리즘은 원하는 결과를 얻게 하며 종료되어야 한다.

가장 간단한 문제로 두 자연수의 최대공약수를 구하는 유클리드 호제법을 생각해보자. 두 자연수 $n_1,\,n_2$ 에 대해 $n_1$ 을 $n_2$ 로 나눈 나머지를 $\text{rem} (n_1,\,n_2)$ 라 하자. 두 자연수 $a$, $b$ 에 대한 최대공약수는 다음과 같은 절차로 얻을 수 있다. 

[과정 1] $a,\,b$ 중 큰 수를 $a_1$, 작은 수를 $b_1$ 이라 하자. $a=b$ 이면 당연히 최대공약수는 $a(=b)$ 이다.

[과정 2] $n=2,\,3,\ldots,$ 에 대해 $a_n$, $b_n$ 이 양의 정수이며 $a_n>b_n$ 일 때 $a_{n+1}=b_n,\, b_{n+1}=\text{rem}( a_n,\,b_n)$ 이라 한다. 이 과정을 $b_n=0$ 이 될 때 까지 수행한다.

[과정 3] $b_{n}=0$ 일 때 $\gcd(a,\,b) = a_{n}$ 이다.  

유클리드 호제법에 대해 다음 명제가 루프불변성을 가짐을 보이자.

1. $a_n > b_n>0$

2. $a_{n+1} < a_n,\, b_{n+1} < b_n$  

첫번째 반복이 시작하기 전에 $a_1 = \max \{a,\,b\},\,b_1 = \min \{a,\,b\}$ 정의했으므로 1번을 만족한다. 2 번은 첫번째 루프에서 만족시킬 필요가 없다.이제 $N$ 번 반복을 수행했을 때 위의 두 명제를 만족한다고 하자. $N+1$ 번 수행한  $a_{n+1},\,b_{n+1}$ 이 이 조건을 만족하는것은 자명하다.
루프가 종료되는 조건은 $a_n=b_n$ 일 때이다. $0<a_{n+1}<a_n$ 이며 $a_n$ 은 항상 자연수이므로 이 알고리즘은 필연적으로 $a_n=b_n$ 이 되어 종료된다. 이때의 값이 두 수 $a,\,b$ 의 최대공약수이다.



Julia 의 `minmax(x, y)` 함수는 `x`, `y` 중 작은값, 큰값을 튜플로 리턴한다. 즉 `minmax(9, 7)=(9, 7)` 이다. 이 함수를 이용하면 간단히 구현 할 수 있다. `gcd` 는 julia 내에 정의된 함수이므로 이것과 구별하기 위해 `mygcd` 함수로 구현해보자.

```julia
function mygcd(a::T, b::T) where T<:Integer 
    a, b = minmax(a, b)
    while(b ≠ 0)
        a, b = b, rem(a, b)
    end
    return a
end
```

</br>

